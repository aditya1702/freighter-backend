This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-04T03:48:22.120Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    runTests.yaml
  dependabot.yml
.husky/
  pre-commit
docs/
  mercury.md
  runbook.md
src/
  helper/
    soroban-rpc/
      index.test.ts
      index.ts
      network.ts
      token.ts
    test/
      metrics.test.ts
    env.ts
    error.ts
    fetch.ts
    format.ts
    horizon-rpc.ts
    mercury.ts
    metrics.ts
    stellar.ts
    test-helper.ts
    validate.ts
  route/
    index.test.ts
    index.ts
    metrics.ts
    validators.ts
  service/
    blockaid/
      helpers/
        addScanResults.ts
      index.ts
    integrity-checker/
      index.ts
      worker.ts
    mercury/
      helpers/
        transformers.ts
      index.test.ts
      index.ts
      queries.ts
    prices/
      errors.ts
      index.ts
      worker.ts
    prometheus-query/
      index.ts
  types/
    js-xdr.d.ts
  config.ts
  index.ts
  logger.ts
.dockerignore
.env-EXAMPLE
.eslintrc.js
.gitignore
CHANGELOG.md
CODE_OF_CONDUCT.MD
compose.yaml
CONTRIBUITING.MD
Dockerfile
jest.config.js
Makefile
package.json
README.md
tsconfig.json
webpack.prod.js

================================================================
Repository Files
================================================================

================
File: .github/workflows/runTests.yaml
================
name: Run Tests
on: [pull_request]
jobs:
  test-ci:
    name: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - run: yarn install
      - run: yarn build:prod
      - run: yarn test:ci

================
File: .github/dependabot.yml
================
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "sunday"
      time: "02:00"
    open-pull-requests-limit: 2
    groups:
      minor-and-patch:
        applies-to: version-updates
        update-types:
        - "patch"
        - "minor"
      major:
        applies-to: version-updates
        update-types:
        - "major"
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "sunday"
      time: "02:00"
    open-pull-requests-limit: 2
    groups:
      all-actions:
        applies-to: version-updates
        patterns: [ "*" ]
  - package-ecosystem: "docker"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "sunday"
      time: "02:00"
    open-pull-requests-limit: 2
    groups:
      all-docker:
        applies-to: version-updates
        patterns: [ "*" ]

================
File: .husky/pre-commit
================
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx pretty-quick --staged

================
File: docs/mercury.md
================
# Mercury Integration Guide

Freighter's backend relies on data that is ingested and indexed by Mercury in order to serve different wallet views.

Mercury is an indexer and API built on Stellar, [see docs for more info.](https://www.mercurydata.app/)
It allows users to subscribe to data on the network and query indexed data using a GraphQL API.

## Playground

To learn more about the available queries or to construct queries, you can use [the playground.](https://api.mercurydata.app:2083/graphiql)

Playground steps -

1. Aquire an access token by signing up for an account on the dashboard.

Testnet - https://test.mercurydata.app/
Pubnet - https://main.mercurydata.app/

Select "Get Access token" under Active Subscriptions and grab your token.

2. Add your access token to the playground.

You can add your token to be used in the requests the playground makes.
Click on the headers tab on the left pane at the bottom and add it in the following format -

```
{
  Authorization: "Bearer <TOKEN>"
}
```

3. Query for data in subscriptions
   At this point you can query for any data that you have a subscription on, for example to get `changeTrust` operations for an account you could run this query -

```
query Test {
  changeTrustByPublicKey(publicKeyText:"<PUBLIC_KEY>") {
    edges {
      node {
        opId
        ...
      }
    }
  }
}
```

## Subscriptions

In order to query data, you must subscribe to it first. Mercury supports subscription APIs for contract events, ledger entries, ledger entry expirations, and accounts.

See [full docs](https://docs.mercurydata.app/mercury-classic/subscriptions/api-definition) for more info.

## Adding a new query

Mercury queries can be added by adding a new key to the `query` map in the [queries file](../src/service/mercury/queries.ts).
Queries are stored as template strings that represent the GraphQL query. Arguments can be passed by writing the query as a function and interpolating the arguments into the template string.

Queries can be imported into anything that accepts GraphQL documents.

## Usage in public facing routes

The account history and account balance queries are used to serve public facing routes, we use [transformers](../src/service/mercury/helpers/transformers.ts) to process this data from Mercury in order to maintain schema compatibility with Horizon/RPC responses.
Any changes to these queries should be accompanied by an update to the corresponding transformer in order align with Horizon schemas used in the transformer.

================
File: docs/runbook.md
================
## Prerequisites

- Node (>=20.0): https://nodejs.org/en/download/
- Yarn (>=v1.22.5): https://classic.yarnpkg.com/en/docs/install
- Docker: (optional) https://docs.docker.com/engine/install/

## Environment

| Variable Name                         | Description                                              |
| ------------------------------------- | -------------------------------------------------------- | ----------- |
| AUTH_EMAIL                            | Email address used to log in to Mercury(pubnet)          |
| AUTH_PASS                             | Password used to log in to Mercury(pubnet)               |
| AUTH_EMAIL_TESTNET                    | Email address used to log in to Mercury(testnet)         |
| AUTH_PASS_TESTNET                     | Password used to log in to Mercury(testnet)              |
| MERCURY_INTEGRITY_CHECK_ACCOUNT_EMAIL | Email address used to log in to Mercury(integrity check) |
| MERCURY_INTEGRITY_CHECK_ACCOUNT_PASS  | Password used to log in to Mercury(integrity check)      |
| REDIS_CONNECTION_NAME                 | Redis connection name                                    |
| REDIS_PORT                            | port for Redis                                           |
| HOSTNAME                              | hostname Redis is running at                             |
| MODE                                  | app run move(development                                 | production) |
| USE_MERCURY                           | flag to toggle use of Mercury                            |
| SENTRY_KEY                            | key to configure Sentry instance                         |
| BLOCKAID_KEY                          | key to configure Blockaid instance                       |

Relies on a Redis instance when `MODE=production`, you can either run `docker compose up` to use docker to stand up a Redis or you can start one on the configured port manually. If you're running in development mode, it uses a memory store instead.

## Setup

To install dependencies, run `yarn i`

## Development

Start development server -
`yarn start`

CLI arguments
-e | --env: (optional) Overrides the environment variable set for `MODE`, should be set to `development|production`
-p | --port: (optional) Sets the application port adn defaults to `3002`

## Production Build

`yarn build:prod`

## Testing

Run unit tests with `yarn test`.

## Mercury Integrity Test

In order to test Mercury for data integrity against Horizon, you can configure your env to `USE_MERCURY=true && MODE=production`.
This will result in a worker that continously processes new blocks, queries both Mercury and Horizon for the same transaction, transforms both responses into a common schema, and finally checks for correctness of the results.

In case of an integrity failure, the `USE_MERCURY` redis flag will be flipped to false and the application will fallback to serving requests from Horizon/Rpc.

## Metrics

Metrics are gathered using [Prometheus](https://prometheus.io/docs/introduction/overview/), and a standalone metrics server runs on the standard Prometheus port and exposes a `/metrics` route for collection.

================
File: src/helper/soroban-rpc/index.test.ts
================
import { xdr } from "stellar-sdk";

import { base64regex, testLogger } from "../test-helper";
import * as networkHelpers from "./network";
import { getIsTokenSpec, isTokenSpec } from "./token";

const { getLedgerKeyContractCode, getLedgerKeyWasmId, parseWasmXdr } =
  networkHelpers;

describe("Soroban RPC helpers", () => {
  const CONTRACT_ID =
    "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP";
  const contractWasmXdr =
    "AAAABwAAAAEAAAAAAAAAAAAACDUAAAAsAAAAAwAAAAAAAAAWAAAAAQAAAAAAAAAPAAAAEQAAAQwmbDlEySR8ddRal6Kd5BG/9Eeto1F1Z1N/sV+i6WsZywAAHO4AYXNtAQAAAAGAARZgBH5+fn4BfmACfn4BfmADfn5+AX5gAX4BfmAAAX5gAX8AYAR/fn9/AGABfwF+YAJ/fwF+YAR/f39/AX5gAn5+AX9gAn9/AGABfgBgA39+fgBgBX5/f39/AGACf34AYAABf2AFfn5+fn8AYAAAYAR+fn5+AGADfn5+AGACfn4AAlsPAWwBNwAAAWwBMQABAWwBXwACAWEBMAADAXgBMQABAXYBZwABAWkBOAADAWkBNwADAWkBNgABAWIBagABAW0BOQACAW0BYQAAAXgBMwAEAWwBMAABAWwBOAABAy0sBQYHCAkBCAQKCwwNDg8QERINEw8UFBQVAAESBwMBAQADAhMAARQCBA8EBBIFAwEAEQYZA38BQYCAwAALfwBBjILAAAt/AEGQgsAACweyAREGbWVtb3J5AgAKaW5pdGlhbGl6ZQAnBG1pbnQAKAlzZXRfYWRtaW4AKwlhbGxvd2FuY2UALQdhcHByb3ZlAC4HYmFsYW5jZQAvCHRyYW5zZmVyADANdHJhbnNmZXJfZnJvbQAyBGJ1cm4AMwlidXJuX2Zyb20ANQhkZWNpbWFscwA2BG5hbWUAOAZzeW1ib2wAOQFfADoKX19kYXRhX2VuZAMBC19faGVhcF9iYXNlAwIKsygsFAAgAEIBQYDLHkGA0h8QkICAgAALJQAgABCRgICAACABIAKtQiCGQgSEIAOtQiCGQgSEEICAgIAAGgvdAQIBfwF+I4CAgIAAQRBrIgEkgICAgAACQAJAAkACQAJAIAAoAgAOBAABAgMAC0HAgcCAAEEJEJKAgIAAIQIgASAAQRBqKQMANwMIIAEgACkDCDcDACACQYiBwIAAQQIgAUECEJOAgIAAEJSAgIAAIQIMAwtByYHAgABBBxCSgICAACAAKQMIEJSAgIAAIQIMAgtB0IHAgABBBRCSgICAACAAKQMIEJSAgIAAIQIMAQsgAUHVgcCAAEEFEJKAgIAANwMAIAFBARCVgICAACECCyABQRBqJICAgIAAIAILxgECAX4EfwJAIAFBCUsNAEIAIQIgASEDIAAhBAJAA0AgA0UNAUEBIQUCQCAELQAAIgZB3wBGDQACQCAGQVBqQf8BcUEKSQ0AAkAgBkG/f2pB/wFxQRpJDQAgBkGff2pB/wFxQRlLDQUgBkFFaiEFDAILIAZBS2ohBQwBCyAGQVJqIQULIAJCBoYgBa1C/wGDhCECIANBf2ohAyAEQQFqIQQMAAsLIAJCCIZCDoQPCyAArUIghkIEhCABrUIghkIEhBCJgICAAAsvAAJAIAEgA0YNAAAACyAArUIghkIEhCACrUIghkIEhCABrUIghkIEhBCKgICAAAs8AQF/I4CAgIAAQRBrIgIkgICAgAAgAiABNwMIIAIgADcDACACQQIQlYCAgAAhASACQRBqJICAgIAAIAELGgAgAK1CIIZCBIQgAa1CIIZCBIQQhYCAgAALcAIBfwF+I4CAgIAAQSBrIgAkgICAgAAgAEIDNwMIAkACQCAAQQhqEJGAgIAAIgFCAhCXgICAAEUNACABQgIQgYCAgAAiAUL/AYNCzQBRDQEAAAtBgIDAgABBKxCYgICAAAALIABBIGokgICAgAAgAQsPACAAIAEQjYCAgABCAVELCQAQn4CAgAAACz0BAX8jgICAgABBIGsiASSAgICAACABQgM3AwggAUEIahCRgICAACAAQgIQgoCAgAAaIAFBIGokgICAgAALrgIDAn8BfgF/I4CAgIAAQcAAayIDJICAgIAAIANBEGogAjcDACADIAE3AwhCACECIANCADcDAAJAAkACQCADEJGAgIAAIgFCABCXgICAAA0AQQAhBEIAIQEMAQsgAUIAEIGAgIAAIQJBACEEAkADQCAEQRBGDQEgA0EYaiAEakICNwMAIARBCGohBAwACwsgAkL/AYNCzABSDQEgAkGwgcCAAEECIANBGGpBAhCbgICAACADQShqIAMpAxgQnICAgAAgAykDKFBFDQEgAykDICICQv8Bg0IEUg0BIAMpAzAhBUIAIANBOGopAwAQnYCAgAAgAkIgiKciBEsiBhshAUIAIAUgBhshAgsgACABNwMIIAAgAjcDACAAIAQ2AhAgA0HAAGokgICAgAAPCwAACzIAAkAgAiAERg0AAAALIAAgAa1CIIZCBIQgA61CIIZCBIQgAq1CIIZCBIQQi4CAgAAaC4MBAgF/AX4CQAJAAkAgAadB/wFxIgJBxQBGDQACQCACQQtHDQAgAEEQaiABQj+HNwMAIAAgAUIIhzcDCAwCCyAAQoOQgICAATcDCEIBIQEMAgsgARCGgICAACEDIAEQh4CAgAAhASAAQRBqIAM3AwAgACABNwMIC0IAIQELIAAgATcDAAsMABCMgICAAEIgiKcLjwIBAn8jgICAgABB0ABrIgUkgICAgAACQCACQgBSIANCAFUgA1AbIgZFDQAQnYCAgAAgBE0NABCfgICAAAALIAVBEGpBEGogATcDACAFIAA3AxggBUIANwMQIAVBKGpBEGogATcDACAFIAA3AzAgBUIANwMoIAVBKGoQkYCAgAAhASAFIAIgAxCggICAACAFIAStQiCGQgSENwNIIAUgBSkDCDcDQCABQbCBwIAAQQIgBUHAAGpBAhCTgICAAEIAEIKAgIAAGgJAIAZFDQACQCAEEJ2AgIAAIgZPDQBBgIDAgABBKxCYgICAAAALIAVBEGpCACAEIAZrIgQgBBCQgICAAAsgBUHQAGokgICAgAALBAAAAAtbAAJAAkAgAUKAgICAgICAwAB8Qv//////////AFYNACABIAGFIAFCP4cgAoWEQgBSDQAgAUIIhkILhCEBDAELIAIgARCIgICAACEBCyAAIAE3AwggAEIANwMAC5IBBAF/AX4BfwF+I4CAgIAAQSBrIgQkgICAgAAgBEEIaiAAIAEQmoCAgAACQCAEKQMIIgUgAlQiBiAEQRBqKQMAIgcgA1MgByADURsNAAJAIAJCAFIgA0IAVSADUBtFDQAgACABIAUgAn0gByADfSAGrX0gBCgCGBCegICAAAsgBEEgaiSAgICAAA8LEJ+AgIAAAAubAQIBfwJ+I4CAgIAAQTBrIgIkgICAgAAgAkIBNwMAIAIgATcDCEIAIQFCACEDAkACQCACEJGAgIAAIgRCARCXgICAAEUNACACQRhqIARCARCBgICAABCcgICAACACKQMYUEUNASACQShqKQMAIQMgAikDICEBIAIQj4CAgAALIAAgAzcDCCAAIAE3AwAgAkEwaiSAgICAAA8LAAALZQEBfyOAgICAAEEwayIDJICAgIAAIANCATcDGCADIAA3AyAgA0EYahCRgICAACEAIANBCGogASACEKCAgIAAIAAgAykDEEIBEIKAgIAAGiADQRhqEI+AgIAAIANBMGokgICAgAALfAIBfwF+I4CAgIAAQRBrIgMkgICAgAAgAyAAEKKAgIAAAkAgA0EIaikDACIEIAKFQn+FIAQgBCACfCADKQMAIgIgAXwiASACVK18IgKFg0IAUw0AIAAgASACEKOAgIAAIANBEGokgICAgAAPC0HggMCAAEEcEJiAgIAAAAuVAQQBfwF+AX8BfiOAgICAAEEQayIDJICAgIAAIAMgABCigICAAAJAAkAgAykDACIEIAFUIgUgA0EIaikDACIGIAJTIAYgAlEbDQAgBiAChSAGIAYgAn0gBa19IgKFg0IAWQ0BQbCAwIAAQSEQmICAgAAACxCfgICAAAALIAAgBCABfSACEKOAgIAAIANBEGokgICAgAALFAACQCABQgBTDQAPCxCfgICAAAAL1gEBAX8jgICAgABBIGsiBCSAgICAAAJAAkAgAEL/AYNCzQBSDQAgAUL/AYNCBFINACACQv8Bg0LJAFINACADQv8Bg0LJAFINACAEQgM3AwggBEEIahCRgICAAEICEJeAgIAADQEgABCZgICAACABQiCIp0ESSw0BIAQgAzcDGCAEIAI3AxAgBCABQoCAgIBwg0IEhDcDCEKOmJ/mw/nBMEH0gcCAAEEDIARBCGpBAxCTgICAAEICEIKAgIAAGiAEQSBqJICAgIAAQgIPCwAACxCfgICAAAALxwECAX8CfiOAgICAAEEwayICJICAgIAAAkAgAEL/AYNCzQBSDQAgAkEYaiABEJyAgIAAIAIpAxhQRQ0AIAIpAyAiASACQShqKQMAIgMQpoCAgAAQloCAgAAiBBCDgICAABoQqYCAgAAgACABIAMQpICAgAAgAiAANwMoIAIgBDcDICACQo7ys9cMNwMYIAJBGGoQqoCAgAAhACACQQhqIAEgAxCggICAACAAIAIpAxAQhICAgAAaIAJBMGokgICAgABCAg8LAAALGwBChICAgICg5QBChICAgICQ9gAQjoCAgAAaC6YBAgF/AX4jgICAgABBMGsiASSAgICAACABIAApAxA3AxAgASAAKQMINwMIIAEgACkDADcDAEEAIQADfgJAIABBGEcNAEEAIQACQANAIABBGEYNASABQRhqIABqIAEgAGopAwA3AwAgAEEIaiEADAALCyABQRhqQQMQlYCAgAAhAiABQTBqJICAgIAAIAIPCyABQRhqIABqQgI3AwAgAEEIaiEADAALC08BAX4CQCAAQv8Bg0LNAFENAAAACxCWgICAACIBEIOAgIAAGhCpgICAACAAEJmAgIAAQo7mrrnqjOTVOCABEKyAgIAAIAAQhICAgAAaQgILlAEBAn8jgICAgABBIGsiAiSAgICAACACIAE3AwggAiAANwMAQQAhAwN+AkAgA0EQRw0AQQAhAwJAA0AgA0EQRg0BIAJBEGogA2ogAiADaikDADcDACADQQhqIQMMAAsLIAJBEGpBAhCVgICAACEBIAJBIGokgICAgAAgAQ8LIAJBEGogA2pCAjcDACADQQhqIQMMAAsLdAEBfyOAgICAAEEwayICJICAgIAAAkAgAEL/AYNCzQBSDQAgAUL/AYNCzQBSDQAQqYCAgAAgAkEYaiAAIAEQmoCAgAAgAkEIaiACKQMYIAJBIGopAwAQoICAgAAgAikDECEAIAJBMGokgICAgAAgAA8LAAALlQICAX8CfiOAgICAAEHAAGsiBCSAgICAAAJAIABC/wGDQs0AUg0AIAFC/wGDQs0AUg0AIARBGGogAhCcgICAACAEKQMYUEUNACADQv8Bg0IEUg0AIARBKGopAwAhAiAEKQMgIQUgABCDgICAABogBSACEKaAgIAAEKmAgIAAIAAgASAFIAIgA0IgiKcQnoCAgABB2oHAgABBBxCSgICAACEGIAQgATcDKCAEIAA3AyAgBCAGNwMYIARBGGoQqoCAgAAhACAEQQhqIAUgAhCggICAACAEIANCgICAgHCDQgSENwM4IAQgBCkDEDcDMCAAIARBMGpBAhCVgICAABCEgICAABogBEHAAGokgICAgABCAg8LAAALYgEBfyOAgICAAEEgayIBJICAgIAAAkAgAEL/AYNCzQBRDQAAAAsQqYCAgAAgAUEQaiAAEKKAgIAAIAEgASkDECABQRhqKQMAEKCAgIAAIAEpAwghACABQSBqJICAgIAAIAALqAECAX8BfiOAgICAAEEgayIDJICAgIAAAkAgAEL/AYNCzQBSDQAgAUL/AYNCzQBSDQAgA0EIaiACEJyAgIAAIAMpAwhQRQ0AIANBGGopAwAhAiADKQMQIQQgABCDgICAABogBCACEKaAgIAAEKmAgIAAIAAgBCACEKWAgIAAIAEgBCACEKSAgIAAIAAgASAEIAIQsYCAgAAgA0EgaiSAgICAAEICDwsAAAtnAQF/I4CAgIAAQTBrIgQkgICAgAAgBCABNwMoIAQgADcDICAEQo7u6pW+tt7zADcDGCAEQRhqEKqAgIAAIQEgBEEIaiACIAMQoICAgAAgASAEKQMQEISAgIAAGiAEQTBqJICAgIAAC8IBAgF/AX4jgICAgABBIGsiBCSAgICAAAJAIABC/wGDQs0AUg0AIAFC/wGDQs0AUg0AIAJC/wGDQs0AUg0AIARBCGogAxCcgICAACAEKQMIUEUNACAEQRhqKQMAIQMgBCkDECEFIAAQg4CAgAAaIAUgAxCmgICAABCpgICAACABIAAgBSADEKGAgIAAIAEgBSADEKWAgIAAIAIgBSADEKSAgIAAIAEgAiAFIAMQsYCAgAAgBEEgaiSAgICAAEICDwsAAAuOAQIBfwF+I4CAgIAAQSBrIgIkgICAgAACQCAAQv8Bg0LNAFINACACQQhqIAEQnICAgAAgAikDCFBFDQAgAkEYaikDACEBIAIpAxAhAyAAEIOAgIAAGiADIAEQpoCAgAAQqYCAgAAgACADIAEQpYCAgAAgACADIAEQtICAgAAgAkEgaiSAgICAAEICDwsAAAtKAQF/I4CAgIAAQRBrIgMkgICAgABCjua3/QkgABCsgICAACEAIAMgASACEKCAgIAAIAAgAykDCBCEgICAABogA0EQaiSAgICAAAuoAQIBfwF+I4CAgIAAQSBrIgMkgICAgAACQCAAQv8Bg0LNAFINACABQv8Bg0LNAFINACADQQhqIAIQnICAgAAgAykDCFBFDQAgA0EYaikDACECIAMpAxAhBCAAEIOAgIAAGiAEIAIQpoCAgAAQqYCAgAAgASAAIAQgAhChgICAACABIAQgAhClgICAACABIAQgAhC0gICAACADQSBqJICAgIAAQgIPCwAAC3ECAX8BfiOAgICAAEEgayIAJICAgIAAAkACQEKOmJ/mw/nBMEICEJeAgIAARQ0AIABCjpif5sP5wTBCAhCBgICAABC3gICAACAAKQMAUA0BCwAACyAAQRhqNQIAIQEgAEEgaiSAgICAACABQiCGQgSEC/cBAgJ/An4jgICAgABBIGsiAiSAgICAAEEAIQMCQANAIANBGEYNASACQQhqIANqQgI3AwAgA0EIaiEDDAALCwJAAkACQAJAIAFC/wGDQswAUg0AIAFB9IHAgABBAyACQQhqQQMQm4CAgAAgAikDCCIBQv8Bg0IEUg0BIAIpAxAiBEL/AYNCyQBSDQICQCACKQMYIgVC/wGDQskAUg0AIAAgBDcDCCAAQgA3AwAgAEEYaiABQiCIpzYCACAAQRBqIAU3AwAMBAsgAEIBNwMADAMLIABCATcDAAwCCyAAQgE3AwAMAQsgAEIBNwMACyACQSBqJICAgIAAC2gCAX8BfiOAgICAAEEgayIAJICAgIAAAkACQEKOmJ/mw/nBMEICEJeAgIAARQ0AIABCjpif5sP5wTBCAhCBgICAABC3gICAACAAKQMAUA0BCwAACyAAKQMIIQEgAEEgaiSAgICAACABC2sCAX8BfiOAgICAAEEgayIAJICAgIAAAkACQEKOmJ/mw/nBMEICEJeAgIAARQ0AIABCjpif5sP5wTBCAhCBgICAABC3gICAACAAKQMAUA0BCwAACyAAQRBqKQMAIQEgAEEgaiSAgICAACABCwIACwuWAgEAQYCAwAALjAJjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAAAAAABhdHRlbXB0IHRvIHN1YnRyYWN0IHdpdGggb3ZlcmZsb3cAAAAAAAAAAAAAAAAAAABhdHRlbXB0IHRvIGFkZCB3aXRoIG92ZXJmbG93ZnJvbXNwZW5kZXIAfAAQAAQAAACAABAABwAAAGFtb3VudGV4cGlyYXRpb25fbGVkZ2VyAJgAEAAGAAAAngAQABEAAABBbGxvd2FuY2VCYWxhbmNlU3RhdGVBZG1pbmFwcHJvdmVkZWNpbWFsbmFtZXN5bWJvbAAA4QAQAAcAAADoABAABAAAAOwAEAAGAAAAAJ8KDmNvbnRyYWN0c3BlY3YwAAAAAAAAAAAAAAAKaW5pdGlhbGl6ZQAAAAAABAAAAAAAAAAFYWRtaW4AAAAAAAATAAAAAAAAAAdkZWNpbWFsAAAAAAQAAAAAAAAABG5hbWUAAAAQAAAAAAAAAAZzeW1ib2wAAAAAABAAAAAAAAAAAAAAAAAAAAAEbWludAAAAAIAAAAAAAAAAnRvAAAAAAATAAAAAAAAAAZhbW91bnQAAAAAAAsAAAAAAAAAAAAAAAAAAAAJc2V0X2FkbWluAAAAAAAAAQAAAAAAAAAJbmV3X2FkbWluAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAlhbGxvd2FuY2UAAAAAAAACAAAAAAAAAARmcm9tAAAAEwAAAAAAAAAHc3BlbmRlcgAAAAATAAAAAQAAAAsAAAAAAAAAAAAAAAdhcHByb3ZlAAAAAAQAAAAAAAAABGZyb20AAAATAAAAAAAAAAdzcGVuZGVyAAAAABMAAAAAAAAABmFtb3VudAAAAAAACwAAAAAAAAARZXhwaXJhdGlvbl9sZWRnZXIAAAAAAAAEAAAAAAAAAAAAAAAAAAAAB2JhbGFuY2UAAAAAAQAAAAAAAAACaWQAAAAAABMAAAABAAAACwAAAAAAAAAAAAAACHRyYW5zZmVyAAAAAwAAAAAAAAAEZnJvbQAAABMAAAAAAAAAAnRvAAAAAAATAAAAAAAAAAZhbW91bnQAAAAAAAsAAAAAAAAAAAAAAAAAAAANdHJhbnNmZXJfZnJvbQAAAAAAAAQAAAAAAAAAB3NwZW5kZXIAAAAAEwAAAAAAAAAEZnJvbQAAABMAAAAAAAAAAnRvAAAAAAATAAAAAAAAAAZhbW91bnQAAAAAAAsAAAAAAAAAAAAAAAAAAAAEYnVybgAAAAIAAAAAAAAABGZyb20AAAATAAAAAAAAAAZhbW91bnQAAAAAAAsAAAAAAAAAAAAAAAAAAAAJYnVybl9mcm9tAAAAAAAAAwAAAAAAAAAHc3BlbmRlcgAAAAATAAAAAAAAAARmcm9tAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAAAAAAAAAAAAAAAACGRlY2ltYWxzAAAAAAAAAAEAAAAEAAAAAAAAAAAAAAAEbmFtZQAAAAAAAAABAAAAEAAAAAAAAAAAAAAABnN5bWJvbAAAAAAAAAAAAAEAAAAQAAAAAQAAAAAAAAAAAAAAEEFsbG93YW5jZURhdGFLZXkAAAACAAAAAAAAAARmcm9tAAAAEwAAAAAAAAAHc3BlbmRlcgAAAAATAAAAAQAAAAAAAAAAAAAADkFsbG93YW5jZVZhbHVlAAAAAAACAAAAAAAAAAZhbW91bnQAAAAAAAsAAAAAAAAAEWV4cGlyYXRpb25fbGVkZ2VyAAAAAAAABAAAAAIAAAAAAAAAAAAAAAdEYXRhS2V5AAAAAAQAAAABAAAAAAAAAAlBbGxvd2FuY2UAAAAAAAABAAAH0AAAABBBbGxvd2FuY2VEYXRhS2V5AAAAAQAAAAAAAAAHQmFsYW5jZQAAAAABAAAAEwAAAAEAAAAAAAAABVN0YXRlAAAAAAAAAQAAABMAAAAAAAAAAAAAAAVBZG1pbgAAAAAAAAEAAAAAAAAAAAAAAA1Ub2tlbk1ldGFkYXRhAAAAAAAAAwAAAAAAAAAHZGVjaW1hbAAAAAAEAAAAAAAAAARuYW1lAAAAEAAAAAAAAAAGc3ltYm9sAAAAAAAQAB4RY29udHJhY3RlbnZtZXRhdjAAAAAAAAAAFAAAAAAAbw5jb250cmFjdG1ldGF2MAAAAAAAAAAFcnN2ZXIAAAAAAAAGMS43NC4xAAAAAAAAAAAACHJzc2RrdmVyAAAALzIwLjMuMSNiYTA0NWE1N2FmOTcxZmM4M2U0NzU3NDZiNTlhNTAzYjdlZjQxNjQ5AAAA";

  describe("getLedgerKeyContractCode", () => {
    it("will return ledger key for contract code", () => {
      const ledgerKeyXdr = getLedgerKeyContractCode(CONTRACT_ID, "TESTNET");
      const ledgerKeyFromXdr = xdr.LedgerKey.fromXDR(ledgerKeyXdr, "base64");

      expect(typeof ledgerKeyXdr).toEqual("string");
      expect(base64regex.test(ledgerKeyXdr)).toBeTruthy();
      expect(ledgerKeyFromXdr).toBeInstanceOf(xdr.LedgerKey);
      expect(ledgerKeyFromXdr.switch().name).toEqual("contractData");
    });
    it("will throw when it fails to get ledger key", () => {
      expect(() =>
        getLedgerKeyContractCode("not contract ID", "TESTNET"),
      ).toThrowError();
    });
  });

  describe("getLedgerKeyWasmId", () => {
    const EXECTUABLE_XDR = "AAAAAGR7a8CMAj18oYkZKn4kqfBSa8oa0Mdoo294cHR1X2nw";
    const executable = xdr.ContractExecutable.fromXDR(EXECTUABLE_XDR, "base64");
    it("will return the contract code ledger key for a contract ID", () => {
      const ledgerKeyWasmId = getLedgerKeyWasmId(executable, "TESTNET");
      const ledgerKeyFromXdr = xdr.LedgerKey.fromXDR(ledgerKeyWasmId, "base64");

      expect(typeof ledgerKeyWasmId).toEqual("string");
      expect(base64regex.test(ledgerKeyWasmId)).toBeTruthy();
      expect(ledgerKeyFromXdr).toBeInstanceOf(xdr.LedgerKey);
      expect(ledgerKeyFromXdr.switch().name).toEqual("contractCode");
    });
  });

  describe("parseWasmXdr", () => {
    it("will return a json schema of a contract spec", async () => {
      const spec = await parseWasmXdr(contractWasmXdr, "TESTNET");
      expect(spec).toHaveProperty("definitions");
    });
  });

  describe("isTokenSpec", () => {
    it("will return a boolean indicating if the spec matches sep41 spec", async () => {
      const spec = await parseWasmXdr(contractWasmXdr, "TESTNET");
      const isSep41 = isTokenSpec(spec);

      expect(isSep41).toBeTruthy();
    });

    it("will return false when the spec does match sep41", async () => {
      const isSep41 = isTokenSpec({ definitions: {} });

      expect(isSep41).toBeFalsy();
    });
  });

  describe("getIsTokenSpec", () => {
    afterAll(() => {
      jest.resetModules();
    });
    it("will return false when the spec cannot be parsed", async () => {
      jest.spyOn(networkHelpers, "getContractSpec").mockImplementation(() => {
        return Promise.resolve({ result: { notDefinitions: {} }, error: null });
      });

      const isSep41 = await getIsTokenSpec("contractId", "TESTNET", testLogger);

      expect(isSep41).toBeFalsy();
    });
  });
});

================
File: src/helper/soroban-rpc/index.ts
================
export * from "./network";
export * from "./token";

================
File: src/helper/soroban-rpc/network.ts
================
import * as StellarSdkNext from "stellar-sdk-next";
import * as StellarSdk from "stellar-sdk";
import { XdrReader } from "@stellar/js-xdr";
import { Logger } from "pino";

import { NetworkNames } from "../validate";
import { ERROR } from "../error";
import { getSdk } from "../stellar";
import { TOKEN_SPEC_DEFINITIONS } from "./token";

const SOROBAN_RPC_URLS: { [key in keyof typeof StellarSdk.Networks]?: string } =
  {
    PUBLIC:
      "http://soroban-rpc-pubnet-prd.soroban-rpc-pubnet-prd.svc.cluster.local:8000",
    TESTNET: "https://soroban-testnet.stellar.org/",
    FUTURENET: "https://rpc-futurenet.stellar.org/",
  };

const getServer = async (network: NetworkNames) => {
  const serverUrl = SOROBAN_RPC_URLS[network];
  if (!serverUrl) {
    throw new Error(ERROR.UNSUPPORTED_NETWORK);
  }

  const Sdk = getSdk(StellarSdkNext.Networks[network]);

  return new Sdk.SorobanRpc.Server(serverUrl, {
    allowHttp: serverUrl.startsWith("http://"),
  });
};

const getTxBuilder = async (
  pubKey: string,
  network: NetworkNames,
  server: StellarSdk.SorobanRpc.Server | StellarSdkNext.SorobanRpc.Server,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const sourceAccount = await server.getAccount(pubKey);
  return new Sdk.TransactionBuilder(sourceAccount, {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks[network],
  });
};

const simulateTx = async <ArgType>(
  tx: StellarSdk.Transaction<
    StellarSdk.Memo<StellarSdk.MemoType>,
    StellarSdk.Operation[]
  >,
  server: StellarSdk.SorobanRpc.Server | StellarSdkNext.SorobanRpc.Server,
  networkPassphrase: StellarSdk.Networks,
): Promise<ArgType> => {
  const Sdk = getSdk(networkPassphrase);
  const simulatedTX = await server.simulateTransaction(tx);
  if (
    Sdk.SorobanRpc.Api.isSimulationSuccess(simulatedTX) &&
    simulatedTX.result
  ) {
    return Sdk.scValToNative(simulatedTX.result.retval);
  }

  if (Sdk.SorobanRpc.Api.isSimulationError(simulatedTX)) {
    throw new Error(simulatedTX.error);
  }

  throw new Error(ERROR.FAILED_TO_SIM);
};

const getLedgerKeyContractCode = (
  contractId: string,
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const { Address, xdr } = Sdk;

  const ledgerKey = xdr.LedgerKey.contractData(
    new xdr.LedgerKeyContractData({
      contract: new Address(contractId).toScAddress(),
      key: xdr.ScVal.scvLedgerKeyContractInstance(),
      durability: xdr.ContractDataDurability.persistent(),
    }),
  );
  return ledgerKey.toXDR("base64");
};

const getExecutable = (
  contractLedgerEntryData: string,
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const { xdr } = Sdk;
  return xdr.LedgerEntryData.fromXDR(contractLedgerEntryData, "base64")
    .contractData()
    .val()
    .instance()
    .executable();
};

const getLedgerKeyWasmId = (
  executable:
    | StellarSdk.xdr.ContractExecutable
    | StellarSdkNext.xdr.ContractExecutable,
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const { xdr } = Sdk;
  const contractCodeWasmHash = executable.wasmHash();
  const ledgerKey = xdr.LedgerKey.contractCode(
    new xdr.LedgerKeyContractCode({
      hash: contractCodeWasmHash,
    }),
  );
  return ledgerKey.toXDR("base64");
};

async function parseWasmXdr(xdrContents: string, network: NetworkNames) {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const { xdr, contract } = Sdk;
  const wasmBuffer = xdr.LedgerEntryData.fromXDR(xdrContents, "base64")
    .contractCode()
    .code();
  const wasmModule = await WebAssembly.compile(wasmBuffer);
  const reader = new XdrReader(
    Buffer.from(
      WebAssembly.Module.customSections(wasmModule, "contractspecv0")[0],
    ),
  );

  const specs = [];
  do {
    specs.push(xdr.ScSpecEntry.read(reader));
  } while (!reader.eof);
  const contractSpec = new contract.Spec(specs);
  return contractSpec.jsonSchema();
}

const getLedgerEntries = async (
  entryKey: string,
  rpcUrl: string,
  id: number = new Date().getDate(),
): Promise<{
  error: Error;
  result: StellarSdk.SorobanRpc.Api.RawGetLedgerEntriesResponse;
}> => {
  let requestBody = {
    jsonrpc: "2.0",
    id: id,
    method: "getLedgerEntries",
    params: {
      keys: [entryKey],
    },
  };

  let res = await fetch(rpcUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(requestBody),
  });
  let json = await res.json();
  if (!res.ok) {
    throw new Error(json);
  }
  return json;
};

const getContractSpec = async (
  contractId: string,
  network: NetworkNames,
  logger: Logger,
) => {
  try {
    const Sdk = getSdk(StellarSdkNext.Networks[network]);
    const { xdr } = Sdk;

    const serverUrl = SOROBAN_RPC_URLS[network];
    if (!serverUrl) {
      throw new Error(ERROR.UNSUPPORTED_NETWORK);
    }

    const contractDataKey = getLedgerKeyContractCode(contractId, network);
    const { error, result } = await getLedgerEntries(
      contractDataKey,
      serverUrl,
    );
    const entries = result.entries || [];
    if (error || !entries.length) {
      logger.error(error);
      return { error: "Unable to fetch contract spec", result: null };
    }

    const contractCodeLedgerEntryData = entries[0].xdr;
    const executable = getExecutable(contractCodeLedgerEntryData, network);
    if (
      executable.switch().name ===
      xdr.ContractExecutableType.contractExecutableStellarAsset().name
    ) {
      return {
        result: TOKEN_SPEC_DEFINITIONS,
        error: null,
      };
    }

    const wasmId = getLedgerKeyWasmId(executable, network);
    const { error: wasmError, result: wasmResult } = await getLedgerEntries(
      wasmId,
      serverUrl,
    );
    const wasmEntries = wasmResult.entries || [];
    if (wasmError || !wasmEntries.length) {
      logger.error(wasmError);
      return { error: "Unable to fetch contract spec", result: null };
    }

    const spec = await parseWasmXdr(wasmEntries[0].xdr, network);
    return { result: spec, error: null };
  } catch (error) {
    logger.error(error);
    return { error: "Unable to fetch contract spec", result: null };
  }
};

export {
  getContractSpec,
  getExecutable,
  getLedgerEntries,
  getLedgerKeyContractCode,
  getLedgerKeyWasmId,
  getServer,
  getTxBuilder,
  parseWasmXdr,
  simulateTx,
  SOROBAN_RPC_URLS,
};

================
File: src/helper/soroban-rpc/token.ts
================
import * as StellarSdkNext from "stellar-sdk-next";
import * as StellarSdk from "stellar-sdk";
import { NetworkNames } from "../validate";
import { Logger } from "pino";
import { getSdk } from "../stellar";
import { getContractSpec, getServer, simulateTx } from "./network";

// https://github.com/stellar/soroban-examples/blob/main/token/src/contract.rs
enum SorobanTokenInterface {
  transfer = "transfer",
  mint = "mint",
}

const TOKEN_SPEC_DEFINITIONS: { [index: string]: any } = {
  allowance: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {
          from: {
            $ref: "#/definitions/Address",
          },
          spender: {
            $ref: "#/definitions/Address",
          },
        },
        type: "object",
        required: ["from", "spender"],
      },
    },
    additionalProperties: false,
  },
  approve: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {
          from: {
            $ref: "#/definitions/Address",
          },
          spender: {
            $ref: "#/definitions/Address",
          },
          amount: {
            $ref: "#/definitions/I128",
          },
          expiration_ledger: {
            $ref: "#/definitions/U32",
          },
        },
        type: "object",
        required: ["from", "spender", "amount", "expiration_ledger"],
      },
    },
    additionalProperties: false,
  },
  balance: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {
          id: {
            $ref: "#/definitions/Address",
          },
        },
        type: "object",
        required: ["id"],
      },
    },
    additionalProperties: false,
  },
  transfer: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {
          from: {
            $ref: "#/definitions/Address",
          },
          to: {
            $ref: "#/definitions/Address",
          },
          amount: {
            $ref: "#/definitions/I128",
          },
        },
        type: "object",
        required: ["from", "to", "amount"],
      },
    },
    additionalProperties: false,
  },
  transfer_from: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {
          spender: {
            $ref: "#/definitions/Address",
          },
          from: {
            $ref: "#/definitions/Address",
          },
          to: {
            $ref: "#/definitions/Address",
          },
          amount: {
            $ref: "#/definitions/I128",
          },
        },
        type: "object",
        required: ["spender", "from", "to", "amount"],
      },
    },
    additionalProperties: false,
  },
  burn: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {
          from: {
            $ref: "#/definitions/Address",
          },
          amount: {
            $ref: "#/definitions/I128",
          },
        },
        type: "object",
        required: ["from", "amount"],
      },
    },
    additionalProperties: false,
  },
  burn_from: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {
          spender: {
            $ref: "#/definitions/Address",
          },
          from: {
            $ref: "#/definitions/Address",
          },
          amount: {
            $ref: "#/definitions/I128",
          },
        },
        type: "object",
        required: ["spender", "from", "amount"],
      },
    },
    additionalProperties: false,
  },
  decimals: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {},
        type: "object",
      },
    },
    additionalProperties: false,
  },
  name: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {},
        type: "object",
      },
    },
    additionalProperties: false,
  },
  symbol: {
    properties: {
      args: {
        additionalProperties: false,
        properties: {},
        type: "object",
      },
    },
    additionalProperties: false,
  },
};

const getTokenDecimals = async (
  contractId: string,
  server: StellarSdk.SorobanRpc.Server | StellarSdkNext.SorobanRpc.Server,
  builder: StellarSdk.TransactionBuilder,
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const contract = new Sdk.Contract(contractId);

  const tx = builder
    .addOperation(contract.call("decimals"))
    .setTimeout(Sdk.TimeoutInfinite)
    .build();

  const result = await simulateTx<string>(
    tx,
    server,
    StellarSdkNext.Networks[network],
  );
  return result;
};

const getTokenName = async (
  contractId: string,
  server: StellarSdk.SorobanRpc.Server | StellarSdkNext.SorobanRpc.Server,
  builder: StellarSdk.TransactionBuilder,
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const contract = new Sdk.Contract(contractId);

  const tx = builder
    .addOperation(contract.call("name"))
    .setTimeout(Sdk.TimeoutInfinite)
    .build();

  const result = await simulateTx<string>(
    tx,
    server,
    StellarSdkNext.Networks[network],
  );
  return result;
};

const getTokenSymbol = async (
  contractId: string,
  server: StellarSdk.SorobanRpc.Server | StellarSdkNext.SorobanRpc.Server,
  builder: StellarSdk.TransactionBuilder,
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const contract = new Sdk.Contract(contractId);

  const tx = builder
    .addOperation(contract.call("symbol"))
    .setTimeout(Sdk.TimeoutInfinite)
    .build();

  const result = await simulateTx<string>(
    tx,
    server,
    StellarSdkNext.Networks[network],
  );
  return result;
};

const getTokenBalance = async (
  contractId: string,
  params: StellarSdk.xdr.ScVal[],
  server: StellarSdk.SorobanRpc.Server | StellarSdkNext.SorobanRpc.Server,
  builder: StellarSdk.TransactionBuilder,
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const contract = new Sdk.Contract(contractId);

  const tx = builder
    .addOperation(contract.call("balance", ...params))
    .setTimeout(Sdk.TimeoutInfinite)
    .build();

  const result = await simulateTx<number>(
    tx,
    server,
    StellarSdkNext.Networks[network],
  );
  return result;
};

const buildTransfer = (
  contractId: string,
  params: StellarSdk.xdr.ScVal[],
  memo: string | undefined,
  builder: StellarSdk.TransactionBuilder,
  networkPassphrase: StellarSdk.Networks,
) => {
  const Sdk = getSdk(networkPassphrase);
  const contract = new Sdk.Contract(contractId);

  const tx = builder
    .addOperation(contract.call("transfer", ...params))
    .setTimeout(Sdk.TimeoutInfinite);

  if (memo) {
    tx.addMemo(Sdk.Memo.text(memo));
  }

  return tx.build();
};

const getIsTokenSpec = async (
  contractId: string,
  network: NetworkNames,
  logger: Logger,
) => {
  try {
    const spec = await getContractSpec(contractId, network, logger);
    if (spec.error) {
      throw new Error(spec.error);
    }
    const res = isTokenSpec(spec.result!);
    return res;
  } catch (error) {
    return false;
  }
};

const isTokenSpec = (spec: Record<string, any>) => {
  for (const tokenMethod of Object.keys(TOKEN_SPEC_DEFINITIONS)) {
    const specMethod = spec.definitions[tokenMethod];
    if (
      !specMethod ||
      JSON.stringify(specMethod) !==
        JSON.stringify(TOKEN_SPEC_DEFINITIONS[tokenMethod])
    ) {
      return false;
    }
  }
  return true;
};

const isSacContractExecutable = async (
  contractId: string,
  network: NetworkNames,
) => {
  // verify the contract executable in the instance entry
  // The SAC has a unique contract executable type
  const Sdk = getSdk(StellarSdkNext.Networks[network]);
  const { xdr } = Sdk;
  const server = await getServer(network);
  const instance = new Sdk.Contract(contractId).getFootprint();
  const ledgerKeyContractCode = instance.toXDR("base64");

  const { entries } = await server.getLedgerEntries(
    xdr.LedgerKey.fromXDR(ledgerKeyContractCode, "base64"),
  );

  if (entries && entries.length) {
    const parsed = entries[0].val;
    const executable = parsed.contractData().val().instance().executable();

    return (
      executable.switch().name ===
      xdr.ContractExecutableType.contractExecutableStellarAsset().name
    );
  }

  return false;
};

const isSacContract = (
  name: string,
  contractId: string,
  network: StellarSdk.Networks,
) => {
  const Sdk = getSdk(network);
  if (name.includes(":")) {
    try {
      return (
        new Sdk.Asset(...(name.split(":") as [string, string])).contractId(
          network,
        ) === contractId
      );
    } catch (error) {
      return false;
    }
  }

  return false;
};

const getOpArgs = (
  fnName: string,
  args: StellarSdk.xdr.ScVal[],
  network: NetworkNames,
) => {
  const Sdk = getSdk(StellarSdk.Networks[network]);

  let amount: number;
  let from;
  let to;

  switch (fnName) {
    case SorobanTokenInterface.transfer:
      from = Sdk.StrKey.encodeEd25519PublicKey(
        args[0].address().accountId().ed25519(),
      );
      to = Sdk.StrKey.encodeEd25519PublicKey(
        args[1].address().accountId().ed25519(),
      );
      amount = Sdk.scValToNative(args[2]).toString();
      break;
    case SorobanTokenInterface.mint:
      to = Sdk.StrKey.encodeEd25519PublicKey(
        args[0].address().accountId().ed25519(),
      );
      amount = Sdk.scValToNative(args[1]).toString();
      break;
    default:
      amount = 0;
  }

  return { from, to, amount };
};

export {
  buildTransfer,
  getIsTokenSpec,
  getOpArgs,
  getTokenBalance,
  getTokenDecimals,
  getTokenName,
  getTokenSymbol,
  isSacContract,
  isSacContractExecutable,
  isTokenSpec,
  SorobanTokenInterface,
  TOKEN_SPEC_DEFINITIONS,
};

================
File: src/helper/test/metrics.test.ts
================
import { httpLabelUrl } from "../metrics";

describe("httpLabelUrl", () => {
  it("should return an account-history label for relevant routes", () => {
    const network = "PUBLIC";
    const route = "account-history";
    const labels = httpLabelUrl(`/api/v1/${route}?network=${network}`);
    expect(labels.network).toEqual(network);
    expect(labels.route).toEqual(route);
  });
  it("should return an account-balances label for relevant routes", () => {
    const network = "TESTNET";
    const route = "account-balances";
    const labels = httpLabelUrl(`/api/v1/${route}?network=${network}`);
    expect(labels.network).toEqual(network);
    expect(labels.route).toEqual(route);
  });
  it("should return the full URL in fall through cases", () => {
    const route = "some-route";
    const labels = httpLabelUrl(`/api/v1/${route}`);
    expect(labels.network).toEqual("unknown");
    expect(labels.route).toEqual(`/api/v1/${route}`);
  });
});

================
File: src/helper/env.ts
================
export type mode = "development" | "production";

export const isValidMode = (str: string) => {
  return str === "development" || str === "production";
};

================
File: src/helper/error.ts
================
export const ERROR = {
  ASSET_TYPE_NOT_SUPPORTED: "unknown asset type",
  ACCOUNT_NOT_SOURCE:
    "Transfer contains authorization entry for a different account",
  AUTH_SUB_INVOCATIONS:
    "Transfer authorizes sub-invocations to another contract",
  FAILED_TO_SIM: "Failed to simulate transaction",
  INVALID_ENV: (key: string) => `ENV configuration invalid - missing ${key}`,
  UNSUPPORTED_NETWORK: "network not supported",
  INVALID_SIMULATION: "Invalid response from simulateTransaction",
  INVALID_VALIDATOR_DEF: "Invalid definition for custom validator",
  TOKEN_SUB_FAILED: "Failed to subscribe to token events",
  SERVER_ERROR: "Unexpected server error",
  MISSING_SUB_FOR_PUBKEY:
    "Tried to query for data without a subscription setup for a public key",
  MISSING_SUB_FOR_TOKEN_BALANCE:
    "Tried to query for data without a subscription setup for a token balance",
  ENTRY_NOT_FOUND: {
    CONTRACT_CODE: "contract code entry not found",
  },
  INVALID_RUN_MODE: "invalid run mode",
  UNABLE_TO_SCAN_SITE: "unable to scan site using blockaid",
  UNABLE_TO_SCAN_TX: "unable to scan tx using blockaid",
  UNABLE_TO_SCAN_ASSET: "unable to scan asset using blockaid",
  SCAN_SITE_DISABLED: "scanning site using blockaid is disabled",
  SCAN_TX_DISABLED: "scanning tx using blockaid is disabled",
  SCAN_ASSET_DISABLED: "scanning asset using blockaid is disabled",
};

================
File: src/helper/fetch.ts
================
// Why does NodeJS.fetch.RequestInfo not work for URL?
// incompatible Fetch definitions between Blockaid and urql libs mean that we can't type this correctly
// and use it in both libs.
export function fetchWithTimeout(
  url: any, // its RequestInfo | URL but urql uses an incorrect fetch definition that clashes with Core.Fetch
  opts?: Record<string, any>,
): any {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), 5000);

  return fetch(url, {
    ...opts,
    signal: controller.signal,
  }).finally(() => {
    clearTimeout(id);
  });
}

================
File: src/helper/format.ts
================
import BigNumber from "bignumber.js";

// Adopted from https://github.com/ethers-io/ethers.js/blob/master/packages/bignumber/src.ts/fixednumber.ts#L27
export const formatTokenAmount = (amount: BigNumber, decimals: number) => {
  let formatted = amount.toString();

  if (decimals > 0) {
    formatted = amount.shiftedBy(-decimals).toFixed(decimals).toString();

    // Trim trailing zeros
    while (formatted[formatted.length - 1] === "0") {
      formatted = formatted.substring(0, formatted.length - 1);
    }

    if (formatted.endsWith(".")) {
      formatted = formatted.substring(0, formatted.length - 1);
    }
  }

  return formatted;
};

================
File: src/helper/horizon-rpc.ts
================
import BigNumber from "bignumber.js";
import * as StellarSdkNext from "stellar-sdk-next";
import * as StellarSdk from "stellar-sdk";
import { getSdk } from "./stellar";

export const BASE_RESERVE = 0.5;
export const BASE_RESERVE_MIN_COUNT = 2;
const TRANSACTIONS_LIMIT = 100;

export enum NETWORK_URLS {
  PUBLIC = "https://horizon.stellar.org",
  TESTNET = "https://horizon-testnet.stellar.org",
  FUTURENET = "https://horizon-futurenet.stellar.org",
  SANDBOX = "",
  STANDALONE = "",
}

export interface Issuer {
  key: string;
  name?: string;
  url?: string;
  hostName?: string;
}

export interface NativeToken {
  type: StellarSdk.AssetType;
  code: string;
}

export interface AssetToken {
  type: StellarSdk.AssetType;
  code: string;
  issuer: Issuer;
  anchorAsset?: string;
  numAccounts?: BigNumber;
  amount?: BigNumber;
  bidCount?: BigNumber;
  askCount?: BigNumber;
  spread?: BigNumber;
}

export type Token = NativeToken | AssetToken;

export interface Balance {
  token: Token;

  // for non-native tokens, this should be total - sellingLiabilities
  // for native, it should also subtract the minimumBalance
  available: BigNumber;
  total: BigNumber;
  buyingLiabilities: BigNumber;
  sellingLiabilities: BigNumber;
}

export interface AssetBalance extends Balance {
  token: AssetToken;
  sponsor?: string;
}

export interface NativeBalance extends Balance {
  token: NativeToken;
  minimumBalance: BigNumber;
}

export interface BalanceMap {
  [key: string]: AssetBalance | NativeBalance;
  native: NativeBalance;
}

export function getBalanceIdentifier(
  balance: StellarSdk.Horizon.HorizonApi.BalanceLine
): string {
  if ("asset_issuer" in balance && !balance.asset_issuer) {
    return "native";
  }
  switch (balance.asset_type) {
    case "credit_alphanum4":
    case "credit_alphanum12":
      return `${balance.asset_code}:${balance.asset_issuer}`;

    case "liquidity_pool_shares":
      return `${balance.liquidity_pool_id}:lp`;

    default:
      return "native";
  }
}

export function getAssetType(code?: string) {
  if (!code) {
    return "native";
  }
  if (code.length > 4) {
    return "credit_alphanum12";
  }
  return "credit_alphanum4";
}

export const makeDisplayableBalances = (
  accountDetails: StellarSdk.Horizon.ServerApi.AccountRecord
) => {
  const { balances, subentry_count, num_sponsored, num_sponsoring } =
    accountDetails;

  const displayableBalances = Object.values(balances).reduce(
    (memo, balance) => {
      const identifier = getBalanceIdentifier(balance);
      const total = new BigNumber(balance.balance);

      let sellingLiabilities = new BigNumber(0);
      let buyingLiabilities = new BigNumber(0);
      let available;

      if ("selling_liabilities" in balance) {
        sellingLiabilities = new BigNumber(balance.selling_liabilities);
        available = total.minus(sellingLiabilities);
      }

      if ("buying_liabilities" in balance) {
        buyingLiabilities = new BigNumber(balance.buying_liabilities);
      }

      if (identifier === "native") {
        // define the native balance line later
        return {
          ...memo,
          native: {
            token: {
              type: "native",
              code: "XLM",
            },
            total,
            available,
            sellingLiabilities,
            buyingLiabilities,

            /* tslint:disable */
            // https://developers.stellar.org/docs/glossary/sponsored-reserves/#sponsorship-effect-on-minimum-balance
            /* tslint:enable */
            minimumBalance: new BigNumber(BASE_RESERVE_MIN_COUNT)
              .plus(subentry_count)
              .plus(num_sponsoring)
              .minus(num_sponsored)
              .times(BASE_RESERVE)
              .plus(sellingLiabilities),
          },
        };
      }

      const liquidityPoolBalance =
        balance as StellarSdk.Horizon.HorizonApi.BalanceLineLiquidityPool;

      if (identifier.includes(":lp")) {
        return {
          ...memo,
          [identifier]: {
            liquidity_pool_id: liquidityPoolBalance.liquidity_pool_id,
            total,
            limit: new BigNumber(liquidityPoolBalance.limit),
          },
        };
      }

      const assetBalance =
        balance as StellarSdk.Horizon.HorizonApi.BalanceLineAsset;
      const assetSponsor = assetBalance.sponsor
        ? { sponsor: assetBalance.sponsor }
        : {};

      return {
        ...memo,
        [identifier]: {
          token: {
            type: assetBalance.asset_type,
            code: assetBalance.asset_code,
            issuer: {
              key: assetBalance.asset_issuer,
            },
          },
          sellingLiabilities,
          buyingLiabilities,
          total,
          limit: new BigNumber(assetBalance.limit),
          available: total.minus(sellingLiabilities),
          ...assetSponsor,
        },
      };
    },
    {}
  );

  return displayableBalances as BalanceMap;
};

export const fetchAccountDetails = async (
  pubKey: string,
  server: StellarSdkNext.Horizon.Server | StellarSdk.Horizon.Server
) => {
  try {
    const accountSummary = await server.accounts().accountId(pubKey).call();

    const balances = makeDisplayableBalances(accountSummary);
    const sponsor = accountSummary.sponsor
      ? { sponsor: accountSummary.sponsor }
      : {};

    return {
      ...sponsor,
      id: accountSummary.id,
      subentryCount: accountSummary.subentry_count,
      sponsoredCount: accountSummary.num_sponsored,
      sponsoringCount: accountSummary.num_sponsoring,
      inflationDestination: accountSummary.inflation_destination,
      thresholds: accountSummary.thresholds,
      signers: accountSummary.signers,
      flags: accountSummary.flags,
      sequenceNumber: accountSummary.sequence,
      balances,
    };
  } catch (error) {
    throw new Error(JSON.stringify(error));
  }
};

export const fetchAccountHistory = async (
  pubKey: string,
  server: StellarSdkNext.Horizon.Server | StellarSdk.Horizon.Server
) => {
  try {
    const operationsData = await server
      .operations()
      .forAccount(pubKey)
      .order("desc")
      .join("transactions")
      .limit(TRANSACTIONS_LIMIT)
      .call();

    return operationsData.records || [];
  } catch (error) {
    throw new Error(JSON.stringify(error));
  }
};

export const submitTransaction = async (
  signedXDR: string,
  networkUrl: string,
  networkPassphrase: string
): Promise<{
  data: StellarSdk.Horizon.HorizonApi.SubmitTransactionResponse | null;
  error: unknown;
}> => {
  const Sdk = getSdk(networkPassphrase as StellarSdk.Networks);
  const tx = Sdk.TransactionBuilder.fromXDR(signedXDR, networkPassphrase);
  const server = new Sdk.Horizon.Server(networkUrl);

  try {
    const data = await server.submitTransaction(tx);
    return {
      data,
      error: null,
    };
  } catch (e: any) {
    if (e.response?.status === 504) {
      // in case of 504, keep retrying this tx until submission succeeds or we get a different error
      // https://developers.stellar.org/api/errors/http-status-codes/horizon-specific/timeout
      // https://developers.stellar.org/docs/encyclopedia/error-handling
      return await submitTransaction(signedXDR, networkUrl, networkPassphrase);
    }
    return {
      data: null,
      error: e?.response?.data,
    };
  }
};

================
File: src/helper/mercury.ts
================
import { Redis } from "ioredis";
import { Client, fetchExchange } from "@urql/core";

import { NetworkNames } from "./validate";
import { mode } from "./env";
import { fetchWithTimeout } from "./fetch";

interface EndpointsMap {
  TESTNET: string;
  PUBLIC: string;
}

export const REDIS_USE_MERCURY_KEY = "USE_MERCURY";

export const hasIndexerSupport = (network: NetworkNames) => {
  return network === "TESTNET" || network === "PUBLIC";
};

export enum MercurySupportedNetworks {
  TESTNET = "TESTNET",
  PUBLIC = "PUBLIC",
}

export const hasSubForPublicKey = (
  subs: { publickey: string }[],
  publicKey: string
) => subs.some((sub: { publickey: string }) => sub.publickey === publicKey);

export const hasSubForTokenBalance = (
  subs: { contractId: string }[],
  contractId: string
) => subs.some((sub: { contractId: string }) => sub.contractId === contractId);

export const getUseMercury = async (
  mode: mode,
  useMercuryConf: boolean,
  redis?: Redis
) => {
  if (mode === "development" || !redis) {
    return useMercuryConf;
  }
  const redisValue = await redis.get(REDIS_USE_MERCURY_KEY);
  return redisValue === "true";
};

export const buildRenewClientMaker =
  (endpoints: EndpointsMap, useTimeout = true) =>
  (network: NetworkNames) => {
    if (!hasIndexerSupport(network)) {
      throw new Error(`network not currently supported: ${network}`);
    }

    return new Client({
      url: endpoints[network as MercurySupportedNetworks],
      exchanges: [fetchExchange],
      fetch: useTimeout ? fetchWithTimeout : fetch,
    });
  };

export const buildBackendClientMaker =
  (endpoints: EndpointsMap, useTimeout = true) =>
  (network: NetworkNames, key: string) => {
    if (!hasIndexerSupport(network)) {
      throw new Error(`network not currently supported: ${network}`);
    }

    return new Client({
      url: `${endpoints[network as MercurySupportedNetworks]}`,
      exchanges: [fetchExchange],
      fetch: useTimeout ? fetchWithTimeout : fetch,
      fetchOptions: () => {
        return {
          headers: { authorization: `Bearer ${key}` },
        };
      },
    });
  };

export const buildCurrentDataClientMaker =
  (endpoints: EndpointsMap, useTimeout = true) =>
  (network: NetworkNames, key: string) => {
    if (!hasIndexerSupport(network)) {
      throw new Error(`network not currently supported: ${network}`);
    }

    return new Client({
      url: `${endpoints[network as MercurySupportedNetworks]}`,
      exchanges: [fetchExchange],
      fetch: useTimeout ? fetchWithTimeout : fetch,
      fetchOptions: () => {
        return {
          headers: { authorization: `Bearer ${key}` },
        };
      },
    });
  };

================
File: src/helper/metrics.ts
================
import { FastifyReply, FastifyRequest } from "fastify";
import Prometheus from "prom-client";

export enum WorkerMessage {
  INTEGRITY_CHECK_PASS = "integrityCheckPass",
  INTEGRITY_CHECK_FAIL = "integrityCheckFail",
}

export const register = new Prometheus.Registry();
register.setDefaultLabels({
  app: "freighter-backend",
});

export const mercuryErrorCounter = new Prometheus.Counter({
  name: "freighter_backend_mercury_error_count",
  help: "Count of errors returned from Mercury",
  labelNames: ["endpoint"],
  registers: [register],
});

export const rpcErrorCounter = new Prometheus.Counter({
  name: "freighter_backend_rpc_error_count",
  help: "Count of errors returned from Horizon or Soroban RPCs",
  labelNames: ["rpc"],
  registers: [register],
});

export const criticalError = new Prometheus.Counter({
  name: "freighter_backend_critical_error_count",
  help: "Count of errors that need manual operator intervention or investigation",
  labelNames: ["message"],
  registers: [register],
});

export const dataIntegrityCheckPass = new Prometheus.Counter({
  name: "freighter_backend_integrity_check_pass",
  help: "Count of times the integrity check has passed between Horizon <-> Mercury",
  labelNames: ["dataIntegrityCheckPass"],
  registers: [register],
});
export const dataIntegrityCheckFail = new Prometheus.Counter({
  name: "freighter_backend_integrity_check_fail",
  help: "Count of times the integrity check has failed between Horizon <-> Mercury",
  labelNames: ["dataIntegrityCheckFail"],
  registers: [register],
});

register.registerMetric(dataIntegrityCheckPass);
register.registerMetric(dataIntegrityCheckFail);

export const httpLabelUrl = (url: string) => {
  const [route, search] = url.split("?");
  const params = new URLSearchParams(search);
  const network = params.get("network") || "unknown";

  if (url.includes("account-history")) {
    return {
      route: "account-history",
      network,
    };
  }

  if (url.includes("account-balances")) {
    return {
      route: "account-balances",
      network,
    };
  }

  if (url.includes("token-details")) {
    return {
      route: "token-details",
      network,
    };
  }

  if (url.includes("token-spec")) {
    return {
      route: "token-spec",
      network,
    };
  }

  if (url.includes("contract-spec")) {
    return {
      route: "contract-spec",
      network,
    };
  }

  return {
    route,
    network,
  };
};

export const getHttpRequestDurationLabels = (
  request: FastifyRequest,
  reply: FastifyReply
) => {
  const { route, network } = httpLabelUrl(request.url);
  return {
    method: request.method,
    route,
    network,
    status: reply.statusCode,
  };
};

================
File: src/helper/stellar.ts
================
import * as StellarSdkNext from "stellar-sdk-next";
import * as StellarSdk from "stellar-sdk";

export const isNextSdk = (networkPassphrase: StellarSdkNext.Networks) =>
  [""].includes(networkPassphrase);

export const getSdk = (networkPassphrase: StellarSdkNext.Networks) =>
  isNextSdk(networkPassphrase) ? StellarSdkNext : StellarSdk;

================
File: src/helper/test-helper.ts
================
import { Client, fetchExchange } from "@urql/core";
import pino from "pino";
import { nativeToScVal } from "stellar-sdk";
import Prometheus from "prom-client";
import Blockaid from "@blockaid/client";

import { mutation, query } from "../service/mercury/queries";
import { MercuryClient } from "../service/mercury";
import { initApiServer } from "../route";
import { NetworkNames } from "./validate";
import { hasIndexerSupport } from "./mercury";
import { BlockAidService } from "../service/blockaid";
import { PriceClient } from "../service/prices";

export const TEST_SOROBAN_TX =
  "AAAAAgAAAACM6IR9GHiRoVVAO78JJNksy2fKDQNs2jBn8bacsRLcrDucaFsAAAWIAAAAMQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAGAAAAAAAAAABHkEVdJ+UfDnWpBr/qF582IEoDQ0iW0WPzO9CEUdvvh8AAAAIdHJhbnNmZXIAAAADAAAAEgAAAAAAAAAAjOiEfRh4kaFVQDu/CSTZLMtnyg0DbNowZ/G2nLES3KwAAAASAAAAAAAAAADoFl2ACT9HZkbCeuaT9MAIdStpdf58wM3P24nl738AnQAAAAoAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAR5BFXSflHw51qQa/6hefNiBKA0NIltFj8zvQhFHb74fAAAACHRyYW5zZmVyAAAAAwAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtysAAAAEgAAAAAAAAAA6BZdgAk/R2ZGwnrmk/TACHUraXX+fMDNz9uJ5e9/AJ0AAAAKAAAAAAAAAAAAAAAAAAAABQAAAAAAAAABAAAAAAAAAAIAAAAGAAAAAR5BFXSflHw51qQa/6hefNiBKA0NIltFj8zvQhFHb74fAAAAFAAAAAEAAAAHa35L+/RxV6EuJOVk78H5rCN+eubXBWtsKrRxeLnnpRAAAAACAAAABgAAAAEeQRV0n5R8OdakGv+oXnzYgSgNDSJbRY/M70IRR2++HwAAABAAAAABAAAAAgAAAA8AAAAHQmFsYW5jZQAAAAASAAAAAAAAAACM6IR9GHiRoVVAO78JJNksy2fKDQNs2jBn8bacsRLcrAAAAAEAAAAGAAAAAR5BFXSflHw51qQa/6hefNiBKA0NIltFj8zvQhFHb74fAAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAOgWXYAJP0dmRsJ65pP0wAh1K2l1/nzAzc/bieXvfwCdAAAAAQBkcwsAACBwAAABKAAAAAAAAB1kAAAAAA==";

export const base64regex =
  /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;

export const testLogger = pino({
  name: "test-logger",
  serializers: {
    req: pino.stdSerializers.req,
    err: pino.stdSerializers.err,
    error: pino.stdSerializers.err,
  },
  transport: {
    target: "pino-pretty",
    options: {
      colorize: true,
    },
  },
});

function renewClientMaker(network: NetworkNames) {
  if (!hasIndexerSupport(network)) {
    throw new Error(`network not currently supported: ${network}`);
  }

  const client = new Client({
    url: `::1:5000/graphql`,
    exchanges: [fetchExchange],
  });

  jest.spyOn(client, "mutation").mockImplementation((_mutation: any): any => {
    switch (_mutation) {
      case mutation.authenticate: {
        return Promise.resolve({
          data: queryMockResponse[mutation.authenticate],
          error: null,
        });
      }
      default:
        throw new Error("unknown mutation in mock");
    }
  });

  return client;
}

function backendClientMaker(network: NetworkNames) {
  if (!hasIndexerSupport(network)) {
    throw new Error(`network not currently supported: ${network}`);
  }

  const client = new Client({
    url: `::1:5000/graphql`,
    exchanges: [fetchExchange],
    fetchOptions: () => {
      return {
        headers: { authorization: "Bearer JWT" },
      };
    },
  });

  jest.spyOn(client, "query").mockImplementation((_query: any): any => {
    switch (_query) {
      case query.getAccountHistory: {
        return Promise.resolve({
          data: queryMockResponse[query.getAccountHistory],
          error: null,
        });
      }
      case query.getAccountBalances(pubKey, tokenBalanceLedgerKey, [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
      ]): {
        return Promise.resolve({
          data: queryMockResponse["query.getAccountBalances"],
          error: null,
        });
      }
      case query.getAccountBalances(pubKey, tokenBalanceLedgerKey, [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
      ]): {
        return Promise.resolve({
          data: queryMockResponse["query.getAccountBalances"],
          error: null,
        });
      }
      case query.getAccountSubForPubKey(pubKey): {
        return Promise.resolve({
          data: {
            allFullAccountSubscriptionsList: [{ publickey: pubKey }],
          },
          error: null,
        });
      }
      case query.getTokenBalanceSub(
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
        tokenBalanceLedgerKey,
      ): {
        return Promise.resolve({
          data: {
            allEntryUpdates: {
              nodes: [
                {
                  contractId:
                    "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
                },
              ],
            },
          },
          error: null,
        });
      }
      case query.getTokenBalanceSub(
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        tokenBalanceLedgerKey,
      ): {
        return Promise.resolve({
          data: {
            allEntryUpdates: {
              nodes: [
                {
                  contractId:
                    "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
                },
              ],
            },
          },
          error: null,
        });
      }
      case query.getTokenBalanceSub(
        "CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
        tokenBalanceLedgerKey,
      ): {
        return Promise.resolve({
          data: {
            allEntryUpdates: {
              nodes: [
                {
                  contractId:
                    "CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
                },
              ],
            },
          },
          error: null,
        });
      }
      case query.getCurrentDataAccountBalances(
        pubKey,
        tokenBalanceLedgerKey,
        [],
      ): {
        return Promise.resolve({
          data: queryMockResponse["query.getAccountBalancesCurrentData"],
          error: null,
        });
      }
      case query.getCurrentDataAccountBalances(pubKey, tokenBalanceLedgerKey, [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
      ]): {
        return Promise.resolve({
          data: queryMockResponse[
            "query.getAccountBalancesCurrentDataWithFirstContracts"
          ],
          error: null,
        });
      }
      case query.getCurrentDataAccountBalances(pubKey, tokenBalanceLedgerKey, [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
      ]): {
        return Promise.resolve({
          data: queryMockResponse[
            "query.getAccountBalancesCurrentDataWithBothContracts"
          ],
          error: null,
        });
      }
      case query.getCurrentDataAccountBalances(pubKey, tokenBalanceLedgerKey, [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
        "CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
      ]): {
        return Promise.resolve({
          data: queryMockResponse[
            "query.getAccountBalancesCurrentDataWithThreeContracts"
          ],
          error: null,
        });
      }
      case query.getAccountObject(pubKey): {
        return Promise.resolve({
          data: queryMockResponse["query.getAccountObject"],
          error: null,
        });
      }
      default:
        throw new Error("unknown query in mock");
    }
  });

  jest.spyOn(client, "mutation").mockImplementation((_mutation: any): any => {
    switch (_mutation) {
      default:
        throw new Error("unknown mutation in mock");
    }
  });

  return client;
}

const backends = {
  TESTNET: `::1:5000/graphql`,
  PUBLIC: `::1:5000/graphql`,
};

const mercurySession = {
  renewClientMaker,
  backendClientMaker,
  currentDataClientMaker: backendClientMaker,
  backends,
  credentials: {
    TESTNET: {
      email: "user-email",
      password: "user-password",
    },
    PUBLIC: {
      email: "user-email",
      password: "user-password",
    },
  },
};

const valueXdr = nativeToScVal(1).toXDR();
const pubKey = "GCGORBD5DB4JDIKVIA536CJE3EWMWZ6KBUBWZWRQM7Y3NHFRCLOKYVAL";
export const contractDataEntryValXdr =
  "AAA5zAAAAAYAAAAAAAAAAY6oGxM6ldCYnaiGZ39Qfe7OU9/hMzrwkVF8OBHpqKMTAAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtysAAAAAQAAAAoAAAAAAAAAAAAAAAAAAAAKAAAAAA==";
const tokenBalanceLedgerKey =
  "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys";

const queryMockResponse = {
  [mutation.authenticate]: {
    authenticate: {
      jwtToken: "mercury-token",
    },
  },
  "query.getAccountBalancesCurrentData": {
    trustlinesByPublicKey: [
      {
        balance: 100019646386,
        asset: "AAAAAUJMTkQAAAAAJgXM07IdPwaDCLLNw46HAu0Jy3Az9GJKesWnsk57zF4=",
        limit: 1,
        accountId: pubKey,
      },
    ],
    accountByPublicKey: {
      accountId: pubKey,
      nativeBalance: "10",
      numSubEntries: "1",
      numSponsored: "1",
      numSponsoring: "1",
      sellingLiabilities: "1000000",
    },
  },
  "query.getAccountBalancesCurrentDataWithFirstContracts": {
    trustlinesByPublicKey: [
      {
        balance: 100019646386,
        asset: "AAAAAUJMTkQAAAAAJgXM07IdPwaDCLLNw46HAu0Jy3Az9GJKesWnsk57zF4=",
        limit: 1,
        accountId: pubKey,
      },
    ],
    accountByPublicKey: {
      accountId: pubKey,
      nativeBalance: "10",
      numSubEntries: "1",
      numSponsored: "1",
      numSponsoring: "1",
      sellingLiabilities: "1000000",
    },
    CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP: [
      {
        contractId: "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        keyXdr:
          "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys",
        valXdr: contractDataEntryValXdr,
        durability: 1,
      },
    ],
  },
  "query.getAccountBalancesCurrentDataWithBothContracts": {
    trustlinesByPublicKey: [
      {
        balance: 100019646386,
        asset: "AAAAAUJMTkQAAAAAJgXM07IdPwaDCLLNw46HAu0Jy3Az9GJKesWnsk57zF4=",
        limit: 1,
        accountId: pubKey,
      },
    ],
    accountByPublicKey: {
      accountId: pubKey,
      nativeBalance: "10",
      numSubEntries: "1",
      numSponsored: "1",
      numSponsoring: "1",
      sellingLiabilities: "1000000",
    },
    CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP: [
      {
        contractId: "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        keyXdr:
          "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys",
        valXdr: contractDataEntryValXdr,
        durability: 1,
      },
    ],
    CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG: [
      {
        contractId: "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
        keyXdr:
          "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys",
        valXdr: contractDataEntryValXdr,
        durability: 1,
      },
    ],
  },
  "query.getAccountBalancesCurrentDataWithThreeContracts": {
    trustlinesByPublicKey: [
      {
        balance: 100019646386,
        asset: "AAAAAUJMTkQAAAAAJgXM07IdPwaDCLLNw46HAu0Jy3Az9GJKesWnsk57zF4=",
        limit: 1,
        accountId: pubKey,
      },
    ],
    accountByPublicKey: {
      accountId: pubKey,
      nativeBalance: "10",
      numSubEntries: "1",
      numSponsored: "1",
      numSponsoring: "1",
      sellingLiabilities: "1000000",
    },
    CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP: [
      {
        contractId: "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        keyXdr:
          "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys",
        valXdr: contractDataEntryValXdr,
        durability: 1,
      },
    ],
    CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG: [
      {
        contractId: "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
        keyXdr:
          "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys",
        valXdr: contractDataEntryValXdr,
        durability: 1,
      },
    ],
    CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ: [
      {
        contractId: "CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
        keyXdr:
          "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys",
        valXdr: contractDataEntryValXdr,
        durability: 1,
      },
    ],
  },
  "query.getAccountObject": {
    accountObjectByPublicKey: {
      nodes: [
        {
          accountByAccount: {
            publickey: pubKey,
          },
          nativeBalance: "10",
          numSubEntries: "1",
          numSponsored: "1",
          numSponsoring: "1",
          sellingLiabilities: "1",
        },
      ],
    },
  },
  "query.getAccountBalances": {
    CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP: {
      nodes: [
        {
          contractId:
            "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
          keyXdr: tokenBalanceLedgerKey,
          valueXdr,
          ledgerTimestamp: "timestamp",
          ledger: "1",
          entryDurability: "persistent",
        },
      ],
    },
    CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG: {
      nodes: [
        {
          contractId:
            "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
          keyXdr: tokenBalanceLedgerKey,
          valueXdr,
          ledgerTimestamp: "timestamp",
          ledger: "1",
          entryDurability: "persistent",
        },
      ],
    },
    CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ: {
      nodes: [
        {
          contractId:
            "CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
          keyXdr: tokenBalanceLedgerKey,
          valueXdr,
          ledgerTimestamp: "timestamp",
          ledger: "1",
          entryDurability: "persistent",
        },
      ],
    },
    balanceByPublicKey: {
      nodes: [],
    },
    accountObjectByPublicKey: {
      nodes: [
        {
          accountByAccount: {
            publickey: pubKey,
          },
          nativeBalance: "10",
          numSubEntries: "1",
          numSponsored: "1",
          numSponsoring: "1",
          sellingLiabilities: "1",
        },
      ],
    },
  },
  [query.getAccountHistory]: {
    invokeHostFnByPublicKey: {
      edges: [],
    },
    createAccountByPublicKey: {
      edges: [],
    },
    createAccountToPublicKey: {
      edges: [],
    },
    paymentsOfPublicKey: {
      edges: [
        {
          node: {
            amount: "50000000",
            assetNative: true,
            accountBySource: {
              publickey:
                "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
            },
            assetByAsset: {
              code: btoa("DT"),
              issuer:
                "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
            },
            accountByDestination: {
              publickey: pubKey,
            },
            id: "12235",
            txInfoByTx: {
              opCount: 1,
              fee: "1000",
              ledgerByLedger: {
                closeTime: 1703024113,
              },
            },
          },
        },
      ],
    },
    pathPaymentsStrictSendOfPublicKey: {
      nodes: [],
    },
    pathPaymentsStrictReceiveOfPublicKey: {
      nodes: [],
    },
    manageBuyOfferByPublicKey: {
      edges: [],
    },
    manageSellOfferByPublicKey: {
      edges: [],
    },
    createPassiveSellOfferByPublicKey: {
      nodes: [],
    },
    changeTrustByPublicKey: {
      nodes: [],
    },
    accountMergeByPublicKey: {
      edges: [],
    },
    bumpSequenceByPublicKey: {
      edges: [],
    },
    claimClaimableBalanceByPublicKey: {
      edges: [],
    },
    createClaimableBalanceByPublicKey: {
      edges: [],
    },
    allowTrustByPublicKey: {
      edges: [],
    },
    manageDataByPublicKey: {
      edges: [],
    },
    beginSponsoringFutureReservesByPublicKey: {
      edges: [],
    },
    endSponsoringFutureReservesByPublicKey: {
      edges: [],
    },
    revokeSponsorshipByPublicKey: {
      edges: [],
    },
    clawbackByPublicKey: {
      edges: [],
    },
    setTrustLineFlagsByPublicKey: {
      edges: [],
    },
    liquidityPoolDepositByPublicKey: {
      edges: [],
    },
    liquidityPoolWithdrawByPublicKey: {
      edges: [],
    },
    createClaimableBalanceToPublicKey: {
      edges: [],
    },
    setOptionsByPublicKey: {
      edges: [],
    },
  },
};

export const register = new Prometheus.Registry();

const mercuryErrorCounter = new Prometheus.Counter({
  name: "freighter_backend_mercury_error_count",
  help: "Count of errors returned from Mercury",
  labelNames: ["endpoint"],
  registers: [register],
});

const rpcErrorCounter = new Prometheus.Counter({
  name: "freighter_backend_rpc_error_count",
  help: "Count of errors returned from Horizon or Soroban RPCs",
  labelNames: ["rpc"],
  registers: [register],
});

const criticalError = new Prometheus.Counter({
  name: "freighter_backend_critical_error_count",
  help: "Count of errors that need manual operator intervention or investigation",
  labelNames: ["message"],
  registers: [register],
});
const mockPriceClient = new PriceClient(testLogger);
const mockMercuryClient = new MercuryClient(
  mercurySession,
  testLogger,
  register,
  {
    mercuryErrorCounter,
    rpcErrorCounter,
    criticalError,
  },
);
jest.mock("@blockaid/client", () => {
  return class Blockaid {};
});
const blockAidClient = new Blockaid();
const blockAidService = new BlockAidService(
  blockAidClient,
  testLogger,
  register,
);

jest
  .spyOn(mockMercuryClient, "tokenDetails")
  .mockImplementation(
    (..._args: Parameters<MercuryClient["tokenDetails"]>): any => {
      return {
        name: "Test Contract",
        decimals: 7,
        symbol: "TST",
      };
    },
  );
async function getDevServer(
  blockaidConfig = {
    useBlockaidAssetScanning: true,
    useBlockaidDappScanning: true,
    useBlockaidTxScanning: true,
  },
) {
  const server = await initApiServer(
    mockMercuryClient,
    blockAidService,
    mockPriceClient,
    testLogger,
    true,
    true,
    register,
    "development",
    blockaidConfig,
  );

  await server.listen();
  return server;
}
export {
  pubKey,
  mockMercuryClient,
  queryMockResponse,
  getDevServer,
  tokenBalanceLedgerKey,
};

================
File: src/helper/validate.ts
================
import { Networks, StrKey } from "stellar-sdk";

export type NetworkNames = keyof typeof Networks;

const isContractId = (contractId: string) => {
  try {
    StrKey.decodeContract(contractId);
    return true;
  } catch (error) {
    return false;
  }
};

const isPubKey = (pubKey: string) => {
  try {
    StrKey.decodeEd25519PublicKey(pubKey);
    return true;
  } catch (error) {
    return false;
  }
};

const isNetwork = (network: string): network is NetworkNames => {
  return Object.keys(Networks).includes(network);
};

export { isContractId, isPubKey, isNetwork };

================
File: src/route/index.test.ts
================
import * as StellarSdk from "stellar-sdk";
import "@blockaid/client";
import {
  getDevServer,
  queryMockResponse,
  pubKey,
  register,
  TEST_SOROBAN_TX,
} from "../helper/test-helper";
import { transformAccountHistory } from "../service/mercury/helpers/transformers";
import { query } from "../service/mercury/queries";
import { defaultBenignResponse } from "../service/blockaid/helpers/addScanResults";
import { Networks } from "stellar-sdk-next";
import { SOROBAN_RPC_URLS } from "../helper/soroban-rpc";
import * as StellarHelpers from "../helper/stellar";

jest.mock("@blockaid/client", () => {
  return class Blockaid {
    tokenBulk = {
      scan: (asset: { tokens: string[]; chain: string }) => {
        const res: { [key: string]: any } = {};
        asset.tokens.forEach((address) => {
          if (
            address ===
            "TST-CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ"
          ) {
            throw Error("ERROR");
          }

          if (
            address ===
            "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56"
          ) {
            res[address] = {
              result_type: "Malicious",
              malicious_score: 1,
            };
            return;
          }

          res[address] = {
            result_type: "Benign",
            malicious_score: 0,
          };
        });

        return Promise.resolve({ results: res });
      },
    };
    token = {
      scan: ({ address }: { address: string }) => {
        if (
          address ===
          "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56"
        ) {
          return Promise.resolve({
            result_type: "Malicious",
            malicious_score: 1,
          });
        }

        return Promise.resolve({
          result_type: "Benign",
          malicious_score: 0,
        });
      },
    };
  };
});

describe("API routes", () => {
  describe("/account-history/:pubKey", () => {
    it("can fetch an account history for a pub key", async () => {
      const server = await getDevServer();
      const response = await fetch(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-history/${pubKey}?network=TESTNET&soroban_rpc_url=rpc_url`,
      );
      const data = await response.json();
      expect(response.status).toEqual(200);
      expect(data).toMatchObject(
        transformAccountHistory(
          {
            data: queryMockResponse[query.getAccountHistory],
          } as any,
          "TESTNET",
        ),
      );
      register.clear();
      await server.close();
    });

    it("rejects requests for non strings that are not pub keys", async () => {
      const notPubkey = "newp";
      const server = await getDevServer();
      const response = await fetch(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-history/${notPubkey}`,
      );
      expect(response.status).toEqual(400);
      register.clear();
      await server.close();
    });
  });
  describe("/account-balances/:pubKey", () => {
    it("can fetch account balances for a pub key & contract IDs", async () => {
      const server = await getDevServer();
      const response = await fetch(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${pubKey}?contract_ids=CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP&network=TESTNET`,
      );
      expect(response.status).toEqual(200);
      register.clear();
      await server.close();
    });

    it("can fetch account balances for a pub key & multiple contract IDs", async () => {
      const contractIds = [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
      ];
      const server = await getDevServer();
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${pubKey}`,
      );
      url.searchParams.append("network", "TESTNET");
      for (const id of contractIds) {
        url.searchParams.append("contract_ids", id);
      }
      const response = await fetch(url.href);
      expect(response.status).toEqual(200);
      register.clear();
      await server.close();
    });

    it("rejects if any contract ID is not valid", async () => {
      const params = {
        contract_ids: [
          "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
          "newp",
        ],
      };
      const server = await getDevServer();
      const response = await fetch(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${pubKey}?${new URLSearchParams(
          params as any,
        )}`,
      );
      expect(response.status).toEqual(400);
      register.clear();
      await server.close();
    });

    it("rejects requests for non strings that are not pub keys", async () => {
      const notPubkey = "newp";
      const server = await getDevServer();
      const response = await fetch(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${notPubkey}?contract_ids=CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP`,
      );
      expect(response.status).toEqual(400);
      register.clear();
      await server.close();
    });

    it("rejects requests with bad contract IDs query param", async () => {
      const notContractId = "newp";
      const server = await getDevServer();
      const response = await fetch(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${pubKey}?contract_ids=${notContractId}`,
      );
      expect(response.status).toEqual(400);
      register.clear();
      await server.close();
    });

    it("adds scanned status on Pubnet", async () => {
      const contractIds = [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
      ];
      const server = await getDevServer();
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${pubKey}`,
      );
      url.searchParams.append("network", "PUBLIC");
      for (const id of contractIds) {
        url.searchParams.append("contract_ids", id);
      }
      const response = await fetch(url.href);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(
        data.balances[
          "BLND:GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56"
        ].blockaidData.result_type,
      ).toEqual("Malicious");
      expect(
        data.balances[
          "TST:CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP"
        ].blockaidData.result_type,
      ).toEqual("Benign");
      register.clear();
      await server.close();
    });
    it("doesn't check scanned status on Testnet", async () => {
      const contractIds = [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
      ];
      const server = await getDevServer();
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${pubKey}`,
      );
      url.searchParams.append("network", "TESTNET");
      for (const id of contractIds) {
        url.searchParams.append("contract_ids", id);
      }
      const response = await fetch(url.href);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(
        data.balances[
          "BLND:GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56"
        ].blockaidData.result_type,
      ).toEqual("Benign");
      register.clear();
      await server.close();
    });
    it("defaults to not malicious on scan status error", async () => {
      const contractIds = [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
        "CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
      ];
      const server = await getDevServer();
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/account-balances/${pubKey}`,
      );
      url.searchParams.append("network", "PUBLIC");
      for (const id of contractIds) {
        url.searchParams.append("contract_ids", id);
      }
      const response = await fetch(url.href);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(
        data.balances[
          "TST:CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ"
        ].blockaidData.result_type,
      ).toEqual("Benign");
      register.clear();
      await server.close();
    });
  });
  describe("/scan-asset-bulk", () => {
    it("can scan assets in bulk", async () => {
      const asset_ids = [
        "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56",
        "FOO-CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
      ];
      const server = await getDevServer();
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/scan-asset-bulk`,
      );
      url.searchParams.append("network", "PUBLIC");
      for (const id of asset_ids) {
        url.searchParams.append("asset_ids", id);
      }
      const response = await fetch(url.href);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(
        data.data.results[
          "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56"
        ],
      ).toEqual({
        result_type: "Malicious",
        malicious_score: 1,
      });
      expect(
        data.data.results[
          "FOO-CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ"
        ],
      ).toEqual({
        result_type: "Benign",
        malicious_score: 0,
      });
      register.clear();
      await server.close();
    });
    it("does not scan assets when config is disabled", async () => {
      const asset_ids = [
        "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56",
        "FOO-CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ",
      ];
      const server = await getDevServer({
        useBlockaidAssetScanning: false,
        useBlockaidDappScanning: false,
        useBlockaidTxScanning: false,
      });
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/scan-asset-bulk`,
      );
      url.searchParams.append("network", "PUBLIC");
      for (const id of asset_ids) {
        url.searchParams.append("asset_ids", id);
      }
      const response = await fetch(url.href);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(
        data.data.results[
          "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56"
        ],
      ).toEqual({
        ...defaultBenignResponse,
      });
      expect(
        data.data.results[
          "FOO-CDP3XWJ4ZN222LKYBMWIY3GYXZYX3KA6WVNDS6V7WKXSYWLAEMYW7DTZ"
        ],
      ).toEqual({
        ...defaultBenignResponse,
      });
      register.clear();
      await server.close();
    });
  });
  describe("/scan-asset", () => {
    it("can scan an asset", async () => {
      const server = await getDevServer();
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/scan-asset`,
      );
      url.searchParams.append(
        "address",
        "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56",
      );
      const response = await fetch(url.href);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(data.data).toEqual({
        result_type: "Malicious",
        malicious_score: 1,
      });
      register.clear();
      await server.close();
    });
    it("does not scan an asset when config is disabled", async () => {
      const server = await getDevServer({
        useBlockaidAssetScanning: false,
        useBlockaidDappScanning: false,
        useBlockaidTxScanning: false,
      });
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/scan-asset`,
      );
      url.searchParams.append(
        "address",
        "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56",
      );
      const response = await fetch(url.href);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(data.data).toEqual({
        ...defaultBenignResponse,
        address:
          "BLND-GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56",
      });
      register.clear();
      await server.close();
    });
  });
  describe("/simulate-tx", () => {
    const simResponse = "simulated xdr";
    const preparedTransaction = "assembled tx xdr";
    let spy: any;

    beforeEach(() => {
      spy = jest
        .spyOn(StellarHelpers, "getSdk")
        .mockImplementation((_networkPassphrase: Networks) => {
          return {
            TransactionBuilder: {
              fromXDR: (_xdr: string, _networkPassphrase: string) => "",
            },
            SorobanRpc: {
              Server: class Server {
                constructor(_url: string) {}
                simulateTransaction = (_tx: string) => simResponse;
              },
              assembleTransaction: (
                _tx: string,
                _simulateTransaction: StellarSdk.rpc.Api.SimulateTransactionResponse,
              ) => {
                return {
                  build: () => {
                    return {
                      toXDR: () => preparedTransaction,
                    };
                  },
                };
              },
            },
          } as any;
        });
    });

    afterEach(() => {
      spy.mockRestore(); // Restore original implementation for the other tests
    });

    it("can simulate a transaction", async () => {
      const server = await getDevServer();
      const url = new URL(
        `http://localhost:${
          (server?.server?.address() as any).port
        }/api/v1/simulate-tx`,
      );
      const options = {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          xdr: TEST_SOROBAN_TX,
          network_url: SOROBAN_RPC_URLS.TESTNET,
          network_passphrase: Networks.TESTNET,
        }),
      };
      const response = await fetch(url.href, options);
      const data = await response.json();

      expect(response.status).toEqual(200);
      expect(data.simulationResponse).toEqual(simResponse);
      expect(data.preparedTransaction).toEqual(preparedTransaction);
      register.clear();
      await server.close();
    });
  });
});

================
File: src/route/index.ts
================
import Fastify, { FastifyRequest } from "fastify";
import axios from "axios";
import helmet from "@fastify/helmet";
import rateLimiter from "@fastify/rate-limit";
import cors from "@fastify/cors";
import { Logger } from "pino";
import { Redis } from "ioredis";
import Prometheus from "prom-client";
import { Networks } from "stellar-sdk-next";
import * as StellarSdk from "stellar-sdk";

import { MercuryClient } from "../service/mercury";
import {
  BlockAidService,
  BlockaidAssetScanResponse,
} from "../service/blockaid";
import {
  addScannedStatus,
  defaultBenignResponse,
} from "../service/blockaid/helpers/addScanResults";
import { ajv } from "./validators";
import {
  isContractId,
  isPubKey,
  isNetwork,
  NetworkNames,
} from "../helper/validate";
import { NETWORK_URLS, submitTransaction } from "../helper/horizon-rpc";
import {
  SOROBAN_RPC_URLS,
  buildTransfer,
  getContractSpec,
  getIsTokenSpec,
  isSacContractExecutable,
} from "../helper/soroban-rpc";
import { ERROR } from "../helper/error";
import { getSdk } from "../helper/stellar";
import { getUseMercury } from "../helper/mercury";
import { getHttpRequestDurationLabels } from "../helper/metrics";
import { mode } from "../helper/env";
import Blockaid from "@blockaid/client";
import { PriceClient, TokenPriceData } from "../service/prices";

const API_VERSION = "v1";

export async function initApiServer(
  mercuryClient: MercuryClient,
  blockAidService: BlockAidService,
  priceClient: PriceClient,
  logger: Logger,
  useMercuryConf: boolean,
  useSorobanPublic: boolean,
  register: Prometheus.Registry,
  mode: mode,
  blockaidConfig: {
    useBlockaidDappScanning: boolean;
    useBlockaidTxScanning: boolean;
    useBlockaidAssetScanning: boolean;
  },
  redis?: Redis,
) {
  const routeMetricsStore = new WeakMap<
    FastifyRequest,
    (labels?: Prometheus.LabelValues<string>) => number
  >();
  const httpRequestDurationMicroseconds = new Prometheus.Histogram({
    name: "http_request_duration_s",
    help: "Duration of HTTP requests in seconds",
    labelNames: ["method", "route", "status", "network"],
    buckets: [0.1, 0.5, 1, 2, 5],
    registers: [register],
  });
  register.registerMetric(httpRequestDurationMicroseconds);

  const server = Fastify({
    loggerInstance: logger,
  });
  server.setValidatorCompiler(({ schema }) => {
    return ajv.compile(schema);
  });
  server.register(rateLimiter, {
    max: 100,
    timeWindow: "1 minute",
    redis,
  });

  server.register(helmet, { global: true });
  await server.register(cors, {
    origin: "*",
  });

  server.addHook("onRequest", (request, _, done) => {
    routeMetricsStore.set(
      request,
      httpRequestDurationMicroseconds.startTimer(),
    );
    return done();
  });

  server.addHook("onResponse", (request, reply, done) => {
    const histMetric = routeMetricsStore.get(request);
    if (!histMetric) {
      return done();
    }

    const labels = getHttpRequestDurationLabels(request, reply);
    histMetric(labels);
    return done();
  });

  server.register(
    function (instance, _opts, next) {
      instance.route({
        method: "GET",
        url: "/ping",
        handler: async (_request, reply) => {
          reply.code(200).send("Alive!");
        },
      });

      instance.route({
        method: "GET",
        url: "/rpc-health",
        schema: {
          querystring: {
            type: "object",
            required: ["network"],
            properties: {
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Querystring: {
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const networkUrl = SOROBAN_RPC_URLS[request.query.network];

          if (!networkUrl) {
            return reply.code(400).send("Unknown network");
          }

          const Sdk = getSdk(StellarSdk.Networks[request.query.network]);
          const { SorobanRpc } = Sdk;

          try {
            const server = new SorobanRpc.Server(networkUrl, {
              allowHttp: networkUrl.startsWith("http://"),
            });

            const health = await server.getHealth();
            reply.code(200).send(health);
          } catch (error) {
            reply.code(200).send({ status: "unhealthy", error });
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/horizon-health",
        schema: {
          querystring: {
            type: "object",
            required: ["network"],
            properties: {
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Querystring: {
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const networkUrl = NETWORK_URLS[request.query.network];

          if (!networkUrl) {
            return reply.code(400).send("Unknown network");
          }

          try {
            // cant use the horizon class from sdk, does not expose health)
            const health = await axios.get(`${networkUrl}/health`);
            reply.code(200).send(health.data);
          } catch (error) {
            reply.code(500).send({
              database_connected: null,
              core_up: null,
              core_synced: null,
            });
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/feature-flags",
        handler: async (_request, reply) => {
          reply.code(200).send({ useSorobanPublic });
        },
      });

      instance.route({
        method: "GET",
        url: "/user-notification",
        handler: async (_request, reply) => {
          const response = {
            enabled: false,
            message: "",
          };
          reply.code(200).send(response);
        },
      });

      instance.route({
        method: "GET",
        url: "/account-history/:pubKey",
        schema: {
          params: {
            type: "object",
            required: ["pubKey"],
            properties: {
              ["pubKey"]: {
                type: "string",
                validator: (pubKey: string) => isPubKey(pubKey),
              },
            },
          },
          querystring: {
            type: "object",
            required: ["network"],
            properties: {
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Params: { ["pubKey"]: string };
            Querystring: {
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          try {
            const useMercury = await getUseMercury(mode, useMercuryConf, redis);
            const pubKey = request.params["pubKey"];
            const { network } = request.query;
            const { data, error } = await mercuryClient.getAccountHistory(
              pubKey,
              network,
              useMercury,
            );
            if (error) {
              reply.code(400).send(JSON.stringify(error));
            } else {
              reply.code(200).send(data);
            }
          } catch (error) {
            logger.error(error);
            reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/account-balances/:pubKey",
        schema: {
          params: {
            type: "object",
            required: ["pubKey"],
            properties: {
              ["pubKey"]: {
                type: "string",
                validator: (pubKey: string) => isPubKey(pubKey),
              },
            },
          },
          querystring: {
            type: "object",
            required: ["network"],
            properties: {
              ["contract_ids"]: {
                type: "array",
                validator: (qStr: Array<unknown>) =>
                  qStr.map((q) => String(q)).every(isContractId),
              },
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Params: { ["pubKey"]: string };
            Querystring: {
              ["contract_ids"]: string[];
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          try {
            const useMercury = await getUseMercury(mode, useMercuryConf, redis);
            const pubKey = request.params["pubKey"];
            const { network } = request.query;

            const skipSorobanPubnet = network === "PUBLIC" && !useSorobanPublic;
            const contractIds =
              request.query["contract_ids"] || ([] as string[]);

            // this returns a composite error/response so we always pass through the whole thing and let the client pick out data/errors.
            const data = await mercuryClient.getAccountBalances(
              pubKey,
              skipSorobanPubnet ? [] : contractIds,
              network,
              useMercury,
            );

            // calculate the USD balance for each token
            // try {
            //   await Promise.all(
            //     Object.entries(data.balances).map(
            //       async ([balanceKey, balance]) => {
            //         const priceUSD = await priceClient.getPrice(balanceKey);
            //         if (priceUSD) {
            //           data.balances[balanceKey] = {
            //             ...(balance as Balance),
            //             availableUSD: (balance as Balance).available.times(
            //               priceUSD.currentPrice,
            //             ),
            //           };
            //         }
            //       },
            //     ),
            //   );
            // } catch (e) {
            //   logger.error("Error calculating USD balance", e);
            // }

            try {
              data.balances = await addScannedStatus(
                data.balances,
                blockAidService,
                network,
                logger,
                blockaidConfig.useBlockaidAssetScanning,
              );
            } catch (e) {
              const scannedBalances = {} as {
                [key: string]: {
                  blockaidData: Blockaid.Token.TokenScanResponse;
                };
              };
              for (const balanceKey of Object.keys(data.balances)) {
                scannedBalances[balanceKey] = {
                  ...data.balances[balanceKey],
                  blockaidData: {
                    ...defaultBenignResponse,
                  },
                };
              }
              data.balances = scannedBalances;
              logger.error(e);
            }

            reply.code(200).send(data);
          } catch (error) {
            logger.error(error);
            reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/token-details/:contractId",
        schema: {
          params: {
            type: "object",
            required: ["contractId"],
            properties: {
              ["contractId"]: {
                type: "string",
                validator: (qStr: string) => isContractId(qStr),
              },
            },
          },
          querystring: {
            type: "object",
            required: ["pub_key", "network"],
            properties: {
              ["pub_key"]: {
                type: "string",
                validator: (pubKey: string) => isPubKey(pubKey),
              },
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Params: { ["contractId"]: string };
            Querystring: {
              ["pub_key"]: string;
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const contractId = request.params["contractId"];
          const { network, pub_key } = request.query;

          const skipSorobanPubnet = network === "PUBLIC" && !useSorobanPublic;
          if (skipSorobanPubnet) {
            return reply.code(400).send("Soroban has been disabled on pubnet");
          }

          try {
            const data = await mercuryClient.tokenDetails(
              pub_key,
              contractId,
              network,
            );
            reply.code(200).send(data);
          } catch (error) {
            reply.code(400).send(error);
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/token-spec/:contractId",
        schema: {
          params: {
            type: "object",
            required: ["contractId"],
            properties: {
              ["contractId"]: {
                type: "string",
                validator: (qStr: string) => isContractId(qStr),
              },
            },
          },
          querystring: {
            type: "object",
            required: ["network"],
            properties: {
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Params: { ["contractId"]: string };
            Querystring: {
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const contractId = request.params["contractId"];
          const { network } = request.query;

          const skipSorobanPubnet = network === "PUBLIC" && !useSorobanPublic;
          if (skipSorobanPubnet) {
            return reply.code(400).send("Soroban has been disabled on pubnet");
          }

          try {
            const isToken = await getIsTokenSpec(contractId, network, logger);

            reply.code(200).send({ data: isToken, error: null });
          } catch (error) {
            reply.code(500).send("Unexpected Server Error");
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/contract-spec/:contractId",
        schema: {
          params: {
            type: "object",
            required: ["contractId"],
            properties: {
              ["contractId"]: {
                type: "string",
                validator: (qStr: string) => isContractId(qStr),
              },
            },
          },
          querystring: {
            type: "object",
            required: ["network"],
            properties: {
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Params: { ["contractId"]: string };
            Querystring: {
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const contractId = request.params["contractId"];
          const { network } = request.query;

          const skipSorobanPubnet = network === "PUBLIC" && !useSorobanPublic;
          if (skipSorobanPubnet) {
            return reply.code(400).send("Soroban has been disabled on pubnet");
          }

          try {
            const { result, error } = await getContractSpec(
              contractId,
              network,
              logger,
            );

            reply.code(error ? 400 : 200).send({ data: result, error });
          } catch (error) {
            reply.code(500).send("Unexpected Server Error");
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/is-sac-contract/:contractId",
        schema: {
          params: {
            type: "object",
            required: ["contractId"],
            properties: {
              ["contractId"]: {
                type: "string",
                validator: (qStr: string) => isContractId(qStr),
              },
            },
          },
          querystring: {
            type: "object",
            required: ["network"],
            properties: {
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Params: { ["contractId"]: string };
            Querystring: {
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const contractId = request.params["contractId"];
          const { network } = request.query;

          const skipSorobanPubnet = network === "PUBLIC" && !useSorobanPublic;
          if (skipSorobanPubnet) {
            return reply.code(400).send("Soroban has been disabled on pubnet");
          }

          try {
            const isSacContract = await isSacContractExecutable(
              contractId,
              network,
            );

            reply.code(200).send({ isSacContract });
          } catch (error) {
            reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "GET",
        url: "/scan-dapp",
        schema: {
          querystring: {
            type: "object",
            required: ["url"],
            properties: {
              ["url"]: {
                type: "string",
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Querystring: {
              ["url"]: string;
            };
          }>,
          reply,
        ) => {
          const { url } = request.query;
          if (blockaidConfig.useBlockaidDappScanning) {
            try {
              const { data, error } = await blockAidService.scanDapp(url);
              return reply.code(error ? 400 : 200).send({ data, error });
            } catch (error) {
              return reply.code(500).send(ERROR.SERVER_ERROR);
            }
          }
          return reply.code(200).send({
            data: { status: "miss" },
            error: ERROR.SCAN_SITE_DISABLED,
          });
        },
      });

      instance.route({
        method: "GET",
        url: "/scan-tx",
        schema: {
          querystring: {
            type: "object",
            required: ["tx_xdr", "url", "network"],
            properties: {
              ["tx_xdr"]: {
                type: "string",
              },
              ["url"]: {
                type: "string",
              },
              ["network"]: {
                type: "string",
                validator: (qStr: string) => isNetwork(qStr),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Querystring: {
              ["tx_xdr"]: string;
              ["url"]: string;
              ["network"]: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const { tx_xdr, url, network } = request.query;
          if (blockaidConfig.useBlockaidTxScanning) {
            try {
              const { data, error } = await blockAidService.scanTx(
                tx_xdr,
                url,
                network,
              );
              return reply.code(error ? 400 : 200).send({ data, error });
            } catch (error) {
              return reply.code(500).send(ERROR.SERVER_ERROR);
            }
          }
          return reply
            .code(200)
            .send({ data: null, error: ERROR.SCAN_TX_DISABLED });
        },
      });

      instance.route({
        method: "GET",
        url: "/scan-asset",
        schema: {
          querystring: {
            type: "object",
            required: ["address"],
            properties: {
              ["address"]: {
                type: "string",
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Querystring: {
              ["address"]: string;
            };
          }>,
          reply,
        ) => {
          const { address } = request.query;

          if (blockaidConfig.useBlockaidAssetScanning) {
            try {
              const { data, error } = await blockAidService.scanAsset(address);
              return reply.code(error ? 400 : 200).send({ data, error });
            } catch (error) {
              return reply.code(500).send(ERROR.SERVER_ERROR);
            }
          }
          return reply.code(200).send({
            data: { ...defaultBenignResponse, address },
            error: ERROR.SCAN_ASSET_DISABLED,
          });
        },
      });

      instance.route({
        method: "GET",
        url: "/scan-asset-bulk",
        schema: {
          querystring: {
            type: "object",
            required: ["asset_ids"],
            properties: {
              ["asset_ids"]: {
                type: "array",
                validator: (qStr: Array<unknown>) =>
                  qStr
                    .map((q) => String(q).split("-")[1])
                    .every((k) => isContractId(k) || isPubKey(k)),
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Querystring: {
              ["asset_ids"]: string[];
            };
          }>,
          reply,
        ) => {
          const { asset_ids } = request.query;
          if (blockaidConfig.useBlockaidAssetScanning) {
            try {
              const { data, error } =
                await blockAidService.scanAssetBulk(asset_ids);
              return reply.code(error ? 400 : 200).send({ data, error });
            } catch (error) {
              return reply.code(500).send(ERROR.SERVER_ERROR);
            }
          }
          const defaultResponse: {
            [addres: string]: BlockaidAssetScanResponse;
          } = {};
          asset_ids.forEach((address) => {
            defaultResponse[address] = {
              ...defaultBenignResponse,
            };
          });
          return reply.code(200).send({
            data: { results: defaultResponse },
            error: ERROR.SCAN_ASSET_DISABLED,
          });
        },
      });

      instance.route({
        method: "GET",
        url: "/token-prices",
        schema: {
          querystring: {
            type: "object",
            required: ["tokens"],
            properties: {
              ["tokens"]: {
                type: "array",
                items: { type: "string" },
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Querystring: {
              ["tokens"]: string[];
            };
          }>,
          reply,
        ) => {
          try {
            const { tokens } = request.query;
            const prices: { [key: string]: TokenPriceData | null } = {};

            // Get prices for all tokens in parallel
            await Promise.all(
              tokens.map(async (token) => {
                prices[token] = await priceClient.getPrice(token);
              }),
            );

            reply.code(200).send({ data: prices });
          } catch (error) {
            logger.error("Error getting token prices:", error);
            reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "POST",
        url: "/subscription/token",
        schema: {
          body: {
            type: "object",
            required: ["contract_id", "pub_key", "network"],
            properties: {
              contract_id: { type: "string" },
              pub_key: { type: "string" },
              network: { type: "string" },
            },
          },
          response: {
            200: {
              type: "object",
              properties: {
                data: { type: "object" },
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Body: {
              contract_id: string;
              pub_key: string;
              network: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const { contract_id, pub_key, network } = request.body;
          const useMercury = await getUseMercury(mode, useMercuryConf, redis);
          if (!useMercury) {
            return reply.code(400).send(JSON.stringify("Mercury disabled"));
          }

          try {
            const { data, error } = await mercuryClient.tokenSubscription(
              contract_id,
              pub_key,
              network,
            );
            if (error) {
              reply.code(400).send(JSON.stringify(error));
            } else {
              reply.code(200).send(data);
            }
          } catch (error) {
            logger.error(error);
            return reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "POST",
        url: "/subscription/account",
        schema: {
          body: {
            type: "object",
            required: ["pub_key", "network"],
            properties: {
              pub_key: { type: "string" },
              network: { type: "string" },
            },
          },
          response: {
            200: {
              type: "object",
              properties: {
                data: { type: "object" },
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Body: { pub_key: string; network: NetworkNames };
          }>,
          reply,
        ) => {
          const { pub_key, network } = request.body;
          const useMercury = await getUseMercury(mode, useMercuryConf, redis);
          if (!useMercury) {
            return reply.code(400).send(JSON.stringify("Mercury disabled"));
          }

          try {
            const { data, error } = await mercuryClient.accountSubscription(
              pub_key,
              network,
            );
            if (error) {
              reply.code(400).send(JSON.stringify(error));
            } else {
              reply.code(200).send(data);
            }
          } catch (error) {
            logger.error(error);
            return reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "POST",
        url: "/subscription/token-balance",
        schema: {
          body: {
            type: "object",
            required: ["contract_id", "pub_key", "network"],
            properties: {
              contract_id: { type: "string" },
              pub_key: { type: "string" },
              network: { type: "string" },
            },
          },
          response: {
            200: {
              type: "object",
              properties: {
                data: { type: "object" },
              },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Body: {
              pub_key: string;
              contract_id: string;
              network: NetworkNames;
            };
          }>,
          reply,
        ) => {
          const { pub_key, contract_id, network } = request.body;

          const useMercury = await getUseMercury(mode, useMercuryConf, redis);
          if (!useMercury) {
            return reply.code(400).send(JSON.stringify("Mercury disabled"));
          }

          try {
            const { data, error } =
              await mercuryClient.tokenBalanceSubscription(
                contract_id,
                pub_key,
                network,
              );
            if (error) {
              reply.code(400).send(JSON.stringify(error));
            } else {
              reply.code(200).send(data);
            }
          } catch (error) {
            logger.error(error);
            return reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "POST",
        url: "/submit-tx",
        schema: {
          body: {
            type: "object",
            required: ["signed_xdr", "network_url", "network_passphrase"],
            properties: {
              signed_xdr: { type: "string" },
              network_url: { type: "string" },
              network_passphrase: { type: "string" },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Body: {
              signed_xdr: string;
              network_url: string;
              network_passphrase: string;
            };
          }>,
          reply,
        ) => {
          const { signed_xdr, network_url, network_passphrase } = request.body;
          try {
            const { data, error } = await submitTransaction(
              signed_xdr,
              network_url,
              network_passphrase,
            );
            if (error) {
              reply.code(400).send(JSON.stringify(error));
            } else {
              reply.code(200).send(data);
            }
          } catch (error) {
            logger.error(error);
            return reply.code(500).send(ERROR.SERVER_ERROR);
          }
        },
      });

      instance.route({
        method: "POST",
        url: "/simulate-tx",
        schema: {
          body: {
            type: "object",
            required: ["xdr", "network_url", "network_passphrase"],
            properties: {
              xdr: { type: "string" },
              network_url: { type: "string" },
              network_passphrase: { type: "string" },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Body: {
              xdr: string;
              network_url: string;
              network_passphrase: string;
            };
          }>,
          reply,
        ) => {
          const { xdr, network_url, network_passphrase } = request.body;

          try {
            const Sdk = getSdk(network_passphrase as Networks);
            const tx = Sdk.TransactionBuilder.fromXDR(xdr, network_passphrase);
            const server = new Sdk.SorobanRpc.Server(network_url);
            const simulationResponse = await server.simulateTransaction(tx);
            const preparedTransaction = Sdk.SorobanRpc.assembleTransaction(
              tx,
              simulationResponse,
            )
              .build()
              .toXDR();

            const data = {
              simulationResponse,
              preparedTransaction,
            };
            reply.code(200).send(data);
          } catch (error) {
            logger.error(JSON.stringify(error));
            reply.code(400).send(JSON.stringify(error));
          }
        },
      });

      instance.route({
        method: "POST",
        url: "/simulate-token-transfer",
        schema: {
          body: {
            type: "object",
            required: [
              "address",
              "pub_key",
              "memo",
              "params",
              "network_url",
              "network_passphrase",
            ],
            properties: {
              address: { type: "string" },
              pub_key: { type: "string" },
              memo: { type: "string" },
              fee: { type: "string" },
              params: { type: "object" },
              network_url: { type: "string" },
              network_passphrase: { type: "string" },
            },
          },
        },
        handler: async (
          request: FastifyRequest<{
            Body: {
              address: string;
              pub_key: string;
              memo: string;
              fee?: string;
              params: Record<string, string>;
              network_url: string;
              network_passphrase: string;
            };
          }>,
          reply,
        ) => {
          const {
            address,
            pub_key,
            memo,
            fee,
            params,
            network_url,
            network_passphrase,
          } = request.body;

          try {
            const Sdk = getSdk(network_passphrase as Networks);
            const _fee = fee || Sdk.BASE_FEE;
            const server = new Sdk.SorobanRpc.Server(network_url, {
              allowHttp: network_url.startsWith("http://"),
            });
            const sourceAccount = await server.getAccount(pub_key);
            const builder = new Sdk.TransactionBuilder(sourceAccount, {
              fee: _fee,
              networkPassphrase: network_passphrase,
            });
            const _params = [
              new Sdk.Address(params.publicKey).toScVal(), // from
              new Sdk.Address(params.destination).toScVal(), // to
              new Sdk.XdrLargeInt("i128", params.amount).toI128(), // amount
            ];
            const tx = buildTransfer(
              address,
              _params,
              memo,
              builder,
              network_passphrase as Networks,
            );
            const simulationResponse = (await server.simulateTransaction(
              tx,
            )) as StellarSdk.SorobanRpc.Api.SimulateTransactionSuccessResponse;

            const preparedTransaction = Sdk.SorobanRpc.assembleTransaction(
              tx,
              simulationResponse,
            );

            const built = preparedTransaction.build();
            switch (built.operations[0].type) {
              case "invokeHostFunction": {
                const sorobanOp = built
                  .operations[0] as StellarSdk.Operation.InvokeHostFunction;
                const auths = sorobanOp.auth || [];

                for (const auth of auths) {
                  if (
                    auth.credentials().switch() !==
                    Sdk.xdr.SorobanCredentialsType.sorobanCredentialsSourceAccount()
                  ) {
                    throw new Error(ERROR.ACCOUNT_NOT_SOURCE);
                  }

                  if (auth.rootInvocation().subInvocations().length) {
                    throw new Error(ERROR.AUTH_SUB_INVOCATIONS);
                  }
                }
              }
            }

            const data = {
              simulationResponse,
              preparedTransaction: built.toXDR(),
            };
            reply.code(200).send(data);
          } catch (error) {
            reply.code(400).send(error);
          }
        },
      });

      next();
    },
    { prefix: `/api/${API_VERSION}` },
  );

  return server;
}

================
File: src/route/metrics.ts
================
import Fastify from "fastify";
import helmet from "@fastify/helmet";
import rateLimiter from "@fastify/rate-limit";
import cors from "@fastify/cors";
import { Redis } from "ioredis";
import Prometheus from "prom-client";

export async function initMetricsServer(
  register: Prometheus.Registry,
  redis?: Redis
) {
  const server = Fastify();
  server.register(rateLimiter, {
    max: 100,
    timeWindow: "1 minute",
    redis,
  });

  server.register(helmet, { global: true });
  await server.register(cors, {
    origin: "*",
  });

  server.register((instance, _opts, next) => {
    instance.route({
      method: "GET",
      url: "/metrics",
      handler: async (_request, reply) => {
        reply.header("Content-Type", register.contentType);
        const data = await register.metrics();
        reply.code(200).send(data);
      },
    });
    next();
  });

  return server;
}

================
File: src/route/validators.ts
================
import Ajv, {
  AnySchemaObject,
  ValidateFunction,
  SchemaValidateFunction,
} from "ajv";
import { ERROR } from "../helper/error";

const ajv = new Ajv({
  removeAdditional: true,
  useDefaults: true,
  coerceTypes: "array",
});

ajv.addKeyword({
  keyword: ["pubKey", "contractId", "validator"],
  compile: (schema: any, parentSchema: AnySchemaObject) => {
    return function validate(data: ValidateFunction) {
      if (typeof schema === "function") {
        const valid = schema(data);
        if (!valid) {
          (validate as SchemaValidateFunction).errors = [
            {
              keyword: "validate",
              message: `: ${data} fails validation`,
              params: { keyword: "validate" },
            },
          ];
        }
        return valid;
      } else if (
        typeof schema === "object" &&
        Array.isArray(schema) &&
        schema.every((f) => typeof f === "function")
      ) {
        const [f, errorMessage] = schema;
        const valid = f(data);
        if (!valid) {
          (validate as SchemaValidateFunction).errors = [
            {
              keyword: "validate",
              message: ": " + errorMessage(schema, parentSchema, data),
              params: { keyword: "validate" },
            },
          ];
        }
        return valid;
      } else {
        throw new Error(ERROR.INVALID_VALIDATOR_DEF);
      }
    };
  },
  errors: true,
});

export { ajv };

================
File: src/service/blockaid/helpers/addScanResults.ts
================
import Blockaid from "@blockaid/client";
import { Logger } from "pino";
import { BlockAidService } from "..";
import { NetworkNames } from "../../../helper/validate";

export const defaultBenignResponse: Blockaid.Token.TokenScanResponse = {
  result_type: "Benign",
  malicious_score: "0.0",
  attack_types: {},
  chain: "stellar",
  address: "",
  metadata: {
    type: "",
  },
  fees: {},
  features: [],
  trading_limits: {},
  financial_stats: {},
};

export const addScannedStatus = async (
  balances: { [key: string]: {} },
  blockaidService: BlockAidService,
  network: NetworkNames,
  logger: Logger,
  useBlockaidAssetScanning: boolean,
) => {
  const scannedBalances = {} as {
    [key: string]: { blockaidData: Blockaid.Token.TokenScanResponse };
  };
  const entries = Object.entries(balances);
  const keyList: string[] = [];

  for (let i = 0; i < entries.length; i++) {
    // iterate over the asset list and create a new list of assets for Blockaid to scan
    const [key, balanceInfo] = entries[i];
    if (key !== "native") {
      try {
        const splitKey = key.split(":");
        const blockaidKey = `${splitKey[0]}-${splitKey[1]}`;
        keyList.push(blockaidKey);
      } catch (e) {
        logger.error(e);
        logger.error(`Failed to split key: ${key}`);
      }
    }

    // set a default as Benign. If we do scan with Blockaid, we will overwrite. Otherwise, we're done
    scannedBalances[key] = {
      ...balanceInfo,
      blockaidData: {
        ...defaultBenignResponse,
      },
    };
  }

  if (network === "PUBLIC" && useBlockaidAssetScanning) {
    // we only scan non-native assets on the public network
    try {
      const bulkRes = await blockaidService.scanAssetBulk(keyList);

      Object.entries(bulkRes?.data?.results || {}).forEach(([key, val]) => {
        try {
          const splitKey = key.split("-");
          const balKey = `${splitKey[0]}:${splitKey[1]}`;

          // overwrite the isMalicious default with the Blockaid scan result
          scannedBalances[balKey].blockaidData = val;
        } catch (e) {
          logger.error(e);
          logger.error(`Failed to process Blockaid scan result: ${key}:${val}`);
        }
      });
    } catch (e) {
      logger.error(e);
      logger.error(`Failed to bulk scan assets: ${JSON.stringify(keyList)}`);
    }
  }

  return scannedBalances;
};

================
File: src/service/blockaid/index.ts
================
import Blockaid from "@blockaid/client";
import Prometheus from "prom-client";
import { Logger } from "pino";
import { Networks, TransactionBuilder } from "stellar-sdk";

import { defaultBenignResponse } from "./helpers/addScanResults";
import { ERROR } from "../../helper/error";
import { NetworkNames } from "../../helper/validate";

const NetworkNameBlockaid: {
  [index: string]: "pubnet" | "futurenet" | "testnet";
} = {
  PUBLIC: "pubnet",
  FUTURENET: "futurenet",
  TESTNET: "testnet",
};

export type BlockaidAssetScanResponse = Blockaid.Token.TokenScanResponse;

export class BlockAidService {
  blockAidClient: Blockaid;
  logger: Logger;
  scanMissCounter: Prometheus.Counter<"scanMiss">;
  constructor(
    blockAidClient: Blockaid,
    logger: Logger,
    register: Prometheus.Registry,
  ) {
    this.blockAidClient = blockAidClient;
    this.logger = logger;
    this.scanMissCounter = new Prometheus.Counter({
      name: "freighter_backend_scan_miss_count",
      help: "Number of times that a blockaid scan has missed",
      labelNames: ["scanMiss"],
      registers: [register],
    });
  }

  scanDapp = async (
    url: string,
  ): Promise<{
    data: Blockaid.Site.SiteScanResponse | null;
    error: string | null;
  }> => {
    try {
      const data = await this.blockAidClient.site.scan({ url });
      return { data, error: null };
    } catch (error) {
      this.logger.error(error);
      this.scanMissCounter.inc();
      return { data: { status: "miss" }, error: ERROR.UNABLE_TO_SCAN_SITE };
    }
  };

  scanTx = async (txXdr: string, url: string, network: NetworkNames) => {
    try {
      const networkPassphrase = Networks[network];
      const tx = TransactionBuilder.fromXDR(txXdr, networkPassphrase);
      let source = "";
      if ("innerTransaction" in tx) {
        source = tx.innerTransaction.source;
      } else {
        source = tx.source;
      }
      const body = {
        chain: NetworkNameBlockaid[network],
        options: ["validation", "simulation"] as Array<
          "validation" | "simulation"
        >,
        metadata: {
          type: "wallet" as "wallet",
          url,
        },
        transaction: txXdr,
        account_address: source,
      };
      const data = await this.blockAidClient.stellar.transaction.scan(body);
      return { data, error: null };
    } catch (error) {
      this.logger.error(error);
      return { data: null, error: ERROR.UNABLE_TO_SCAN_TX };
    }
  };

  scanAsset = async (
    address: string,
  ): Promise<{
    data: Blockaid.Token.TokenScanResponse | null;
    error: string | null;
  }> => {
    try {
      const data = await this.blockAidClient.token.scan({
        address,
        chain: "stellar",
      });
      return { data, error: null };
    } catch (error) {
      this.logger.error(error);
      this.scanMissCounter.inc();
      return { data: null, error: ERROR.UNABLE_TO_SCAN_ASSET };
    }
  };

  scanAssetBulk = async (
    addressList: string[],
  ): Promise<{
    data: Blockaid.TokenBulk.TokenBulkScanResponse | null;
    error: string | null;
  }> => {
    try {
      const data = await this.blockAidClient.tokenBulk.scan({
        tokens: addressList,
        chain: "stellar",
      });
      return { data, error: null };
    } catch (error) {
      this.logger.error(error);
      this.scanMissCounter.inc();
      const defaultResponse: {
        [addres: string]: Blockaid.Token.TokenScanResponse;
      } = {};
      addressList.forEach((address) => {
        defaultResponse[address] = {
          ...defaultBenignResponse,
        };
      });

      return {
        data: { results: defaultResponse },
        error: ERROR.UNABLE_TO_SCAN_ASSET,
      };
    }
  };
}

================
File: src/service/integrity-checker/index.ts
================
import { Logger } from "pino";
import { Networks, Horizon } from "stellar-sdk";
import { Redis } from "ioredis";
import * as Sentry from "@sentry/node";
import { parentPort } from "worker_threads";

import { getSdk } from "../../helper/stellar";
import { NETWORK_URLS } from "../../helper/horizon-rpc";
import { NetworkNames } from "../../helper/validate";
import { MercuryClient } from "../mercury";
import { REDIS_USE_MERCURY_KEY } from "../../helper/mercury";
import { WorkerMessage } from "../../helper/metrics";

const CHECK_INTERVAL = 5;
const EPOCHS_TO_CHECK = 5;
const SKIP_KEYS = ["created_at"];

const alertFailure = (opId: string, client: Sentry.NodeClient) => {
  const err = new Error(
    `Failed Mercury integrity check, operation ID: ${opId}`
  );
  err.name = "Mercury integrity check failed";
  client.captureException(err);
};

export class IntegrityChecker {
  logger: Logger;
  lastCheckedLedger: number;
  mercuryClient: MercuryClient;
  redisClient: Redis;
  sentryClient: Sentry.NodeClient;

  constructor(
    logger: Logger,
    mercuryClient: MercuryClient,
    redisClient: Redis,
    sentryClient: Sentry.NodeClient
  ) {
    this.logger = logger;
    this.lastCheckedLedger = 0;
    this.mercuryClient = mercuryClient;
    this.redisClient = redisClient;
    this.sentryClient = sentryClient;
  }

  watchLedger = async (network: NetworkNames, cursor: string = "now") => {
    const networkUrl = NETWORK_URLS[network];
    const sdk = getSdk(Networks[network]);
    const server = new sdk.Horizon.Server(networkUrl);
    this.logger.info("Starting ledger watcher...");
    server
      .ledgers()
      .cursor(cursor)
      .stream({
        onmessage: (ledger) => this.onNewLedger(ledger, network),
        onerror: (error) => {
          this.logger.error("Error in ledger stream:", error);
          return this.watchLedger(network, cursor);
        },
      });
  };

  onNewLedger = async (ledger: unknown, network: NetworkNames) => {
    // TODO: is ledger arg type wrong in the sdk? ServerApi.CollectionPage<ServerApi.LedgerRecord>
    const _ledger = ledger as Horizon.ServerApi.LedgerRecord;

    if (
      this.lastCheckedLedger + CHECK_INTERVAL > _ledger.sequence &&
      this.lastCheckedLedger !== 0
    ) {
      return;
    }

    this.lastCheckedLedger = _ledger.sequence;
    const ops = await _ledger.operations();
    const firstOp = ops.records[0];
    if (firstOp) {
      const redisUseMercuryFlag = await this.redisClient.get(
        REDIS_USE_MERCURY_KEY
      );
      const redisUseMercury = redisUseMercuryFlag === "true";
      try {
        await this.checkOperationIntegrity(firstOp, network, redisUseMercury);
      } catch (error) {
        this.logger.error(error);
        parentPort?.postMessage({ type: WorkerMessage.INTEGRITY_CHECK_FAIL });
        if (redisUseMercury) {
          alertFailure(firstOp.id, this.sentryClient);
        }
        await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
      }
    }
  };

  checkHydrateAndMatchOps = async (
    hydrationId: number,
    sourceAccount: string,
    operation: Horizon.ServerApi.OperationRecord,
    network: NetworkNames,
    redisUseMercury: boolean
  ) => {
    const hydration = await this.mercuryClient.checkHydrationStatus(
      hydrationId,
      network
    );
    if (hydration.status === "complete") {
      await this.matchOperations(
        sourceAccount,
        operation,
        network,
        redisUseMercury
      );
      return;
    }

    if (hydration.status === "not complete") {
      await this.checkHydrateAndMatchOps(
        hydrationId,
        sourceAccount,
        operation,
        network,
        redisUseMercury
      );
      return;
    }
    throw new Error("hydration check error");
  };

  subscribeAndCheckOp = async (
    sourceAccount: string,
    operation: Horizon.ServerApi.OperationRecord,
    network: NetworkNames,
    redisUseMercury: boolean
  ) => {
    try {
      const { data, error } = await this.mercuryClient.accountSubscription(
        sourceAccount,
        network,
        EPOCHS_TO_CHECK
      );
      if (error) {
        throw new Error(error as any);
      }

      this.logger.info(`Subscribed to account ${sourceAccount}`);
      await this.checkHydrateAndMatchOps(
        data.id,
        sourceAccount,
        operation,
        network,
        redisUseMercury
      );
    } catch (error) {
      this.logger.error(
        `Failed to subscribe to account to perform integrity check`
      );
      this.logger.error(error);
      parentPort?.postMessage({ type: WorkerMessage.INTEGRITY_CHECK_FAIL });
      if (redisUseMercury) {
        alertFailure(operation.id, this.sentryClient);
      }
      await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
    }
  };

  checkOperationIntegrity = async (
    operation: Horizon.ServerApi.OperationRecord,
    network: NetworkNames,
    redisUseMercury: boolean
  ) => {
    const sourceAccount = operation.source_account;
    this.logger.info(`Checking integrity of operation ID: ${operation.id}`);
    await this.subscribeAndCheckOp(
      sourceAccount,
      operation,
      network,
      redisUseMercury
    );
  };

  matchOperations = async (
    sourceAccount: string,
    operation: Horizon.ServerApi.OperationRecord,
    network: NetworkNames,
    redisUseMercury: boolean
  ) => {
    const opId = operation.id;
    const { data: history, error: mercuryHistoryError } =
      await this.mercuryClient.getAccountHistoryMercury(sourceAccount, network);
    const { data: historyHorizon } =
      await this.mercuryClient.getAccountHistoryHorizon(sourceAccount, network);

    if (history && historyHorizon) {
      const match = history.find((historyItem) => historyItem.id === opId);
      const matchHorizon = historyHorizon.find(
        (historyItem) => historyItem.id === opId
      );

      if (match && matchHorizon) {
        for (const key of Object.keys(match)) {
          const mercuryValue = (match as any)[key];
          const horizonValue = (matchHorizon as any)[key];

          if (!mercuryValue || !horizonValue) {
            this.logger.error(
              `Missing field for key ${key}, horizon: ${horizonValue}, mercury: ${mercuryValue}`
            );
            parentPort?.postMessage({
              type: WorkerMessage.INTEGRITY_CHECK_FAIL,
            });
            if (redisUseMercury) {
              alertFailure(operation.id, this.sentryClient);
            }
            await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
            return;
          }

          // if key is array or object, check members
          if (Array.isArray(mercuryValue) && Array.isArray(horizonValue)) {
            for (var i = 0; i < mercuryValue.length; i++) {
              if (mercuryValue[i] !== horizonValue[i]) {
                this.logger.error(
                  `Failed check for operation ID - ${operation.id}, key - ${key}`
                );
                parentPort?.postMessage({
                  type: WorkerMessage.INTEGRITY_CHECK_FAIL,
                });
                if (redisUseMercury) {
                  alertFailure(operation.id, this.sentryClient);
                }
                await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
                return;
              }
            }
          }

          if (
            mercuryValue.constructor === Object &&
            horizonValue.constructor === Object
          ) {
            for (const valKey of Object.keys(mercuryValue)) {
              if (mercuryValue[valKey] !== horizonValue[valKey]) {
                this.logger.error(
                  `Failed check for operation ID - ${operation.id}, key - ${key}`
                );
                parentPort?.postMessage({
                  type: WorkerMessage.INTEGRITY_CHECK_FAIL,
                });
                if (redisUseMercury) {
                  alertFailure(operation.id, this.sentryClient);
                }
                await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
                return;
              }
            }
          }

          if (mercuryValue !== horizonValue && !SKIP_KEYS.includes(key)) {
            this.logger.error(
              `Failed check for operation ID - ${operation.id}, key - ${key}`
            );
            parentPort?.postMessage({
              type: WorkerMessage.INTEGRITY_CHECK_FAIL,
            });
            if (redisUseMercury) {
              alertFailure(operation.id, this.sentryClient);
            }
            await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
            return;
          } else {
            this.logger.info(`Passed check for op ${opId}`);
            parentPort?.postMessage({
              type: WorkerMessage.INTEGRITY_CHECK_PASS,
            });
            //  no need to flip REDIS_USE_MERCURY_KEY to true, this is done manually on intervention after a failure.
            return;
          }
        }
      } else {
        if (!match) {
          this.logger.error(
            `Failed to find matching operation from Mercury, ID: ${opId}, source: ${operation.source_account}`
          );
          parentPort?.postMessage({ type: WorkerMessage.INTEGRITY_CHECK_FAIL });
          if (redisUseMercury) {
            alertFailure(operation.id, this.sentryClient);
          }
          await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
          return;
        }
        if (!matchHorizon) {
          this.logger.error(
            `Failed to find matching operation from Horizon, ID: ${opId}`
          );
        }
      }
    } else {
      if (!historyHorizon) {
        this.logger.error(`Failed to get history from Horizon`);
      }
      if (!history) {
        this.logger.error(`Failed to get history from Mercury`);
        this.logger.error(mercuryHistoryError);
        parentPort?.postMessage({ type: WorkerMessage.INTEGRITY_CHECK_FAIL });
        if (redisUseMercury) {
          alertFailure(operation.id, this.sentryClient);
        }
        await this.redisClient.set(REDIS_USE_MERCURY_KEY, "false");
      }
    }
  };
}

================
File: src/service/integrity-checker/worker.ts
================
import { Redis } from "ioredis";
import * as Sentry from "@sentry/node";
import { workerData } from "worker_threads";

import { IntegrityChecker } from ".";
import { logger } from "../../logger";
import {
  buildBackendClientMaker,
  buildCurrentDataClientMaker,
  buildRenewClientMaker,
} from "../../helper/mercury";
import { MercuryClient } from "../mercury";
import {
  register,
  mercuryErrorCounter,
  rpcErrorCounter,
  criticalError,
} from "../../helper/metrics";

const {
  hostname,
  mercuryBackendPubnet,
  mercuryBackendTestnet,
  mercuryEmailTestnet,
  mercuryGraphQLCurrentDataPubnet,
  mercuryGraphQLCurrentDataTestnet,
  mercuryGraphQLPubnet,
  mercuryGraphQLTestnet,
  mercuryIntegrityCheckEmail,
  mercuryIntegrityCheckPass,
  mercuryPasswordTestnet,
  redisConnectionName,
  redisPort,
  sentryKey,
} = workerData;

const main = async () => {
  const sentryClient = Sentry.init({
    dsn: sentryKey,
  });

  if (!sentryKey || !sentryClient) {
    throw new Error(
      `Sentry misconfiguration, dsn: ${sentryKey}, client: ${sentryClient}`
    );
  }

  const graphQlEndpoints = {
    TESTNET: mercuryGraphQLTestnet,
    PUBLIC: mercuryGraphQLPubnet,
  };

  const graphQlCurrentDataEndpoints = {
    TESTNET: mercuryGraphQLCurrentDataTestnet,
    PUBLIC: mercuryGraphQLCurrentDataPubnet,
  };

  const backends = {
    TESTNET: mercuryBackendTestnet,
    PUBLIC: mercuryBackendPubnet,
  };

  const redis = new Redis({
    connectionName: redisConnectionName,
    host: hostname,
    port: redisPort,
    maxRetriesPerRequest: 1,
  });

  redis.on("error", (error: any) => {
    logger.info("redis connection error", error);
    throw new Error(error);
  });

  const checkNetwork = "PUBLIC";
  // initial token and userID not needed for integrity checks
  const integrityCheckMercurySession = {
    renewClientMaker: buildRenewClientMaker(graphQlEndpoints, false),
    backendClientMaker: buildBackendClientMaker(graphQlEndpoints, false),
    currentDataClientMaker: buildCurrentDataClientMaker(
      graphQlCurrentDataEndpoints,
      false
    ),
    backends,
    credentials: {
      TESTNET: {
        email: mercuryEmailTestnet,
        password: mercuryPasswordTestnet,
      },
      // need to set this to the integrity check accounts for Mercury to remove entries periodically
      PUBLIC: {
        email: mercuryIntegrityCheckEmail,
        password: mercuryIntegrityCheckPass,
      },
    },
  };

  const integrityCheckMercuryClient = new MercuryClient(
    integrityCheckMercurySession,
    logger,
    register,
    {
      mercuryErrorCounter,
      rpcErrorCounter,
      criticalError,
    },
    redis
  );

  const integrityCheckerClient = new IntegrityChecker(
    logger,
    integrityCheckMercuryClient,
    redis,
    sentryClient
  );
  await integrityCheckerClient.watchLedger(checkNetwork);
};

main().catch((e) => {
  logger.error(e);
});

================
File: src/service/mercury/helpers/transformers.ts
================
import { OperationResult } from "@urql/core";
import * as StellarSdk from "stellar-sdk";
import BigNumber from "bignumber.js";
import {
  BASE_RESERVE,
  BASE_RESERVE_MIN_COUNT,
  NativeBalance,
  getAssetType,
} from "../../../helper/horizon-rpc";
import { formatTokenAmount } from "../../../helper/format";
import { getOpArgs, isSacContract } from "../../../helper/soroban-rpc";
import { getSdk } from "../../../helper/stellar";
import { NetworkNames } from "../../../helper/validate";

// Transformers take an API response, and transform it/augment it for frontend consumption

export interface BalanceMap {
  [key: string]: any;
  native: NativeBalance;
}

export type Balances = BalanceMap | null;

interface AccountBalancesInterface {
  balances: Balances;
  isFunded: boolean | null;
  subentryCount: number;
}

type MercuryAccountBalancesCurrentData = {
  trustlinesByPublicKey: {
    balance: string;
    asset: string;
    limit: number;
    accountId: string;
  }[];
  accountByPublicKey: {
    accountId: string;
    nativeBalance: string;
    buyingLiabilities: string;
    sellingLiabilities: string;
    seqNum: string;
    numSubentries: string;
    numSponsored: string;
    numSponsoring: string;
  };
} & {
  [key: string]: {
    contractId: string;
    keyXdr: string;
    valXdr: string;
    durability: string;
  };
};

type MercuryAccountBalancesData = {
  accountObjectByPublicKey: {
    nodes: {
      accountByAccount: {
        publickey: string;
      };
      nativeBalance: string;
      numSubEntries: string;
      numSponsored: string;
      numSponsoring: string;
      sellingLiabilities: string;
    }[];
  };
  balanceByPublicKey: {
    nodes: {
      assetByAsset: {
        code: string;
        issuer: string;
      };
      accountByAccount: {
        publickey: string;
      };
      balance: string;
    }[];
  };
} & {
  // each entryUpdateByContractIdAndKey query is aliased as the contract ID, to support querying for multiple balance entries
  [key: string]: {
    nodes: {
      contractId: string;
      keyXdr: string;
      valueXdr: string;
    }[];
  };
};

interface TokenDetails {
  [k: string]: {
    name: string;
    symbol: string;
    decimals: string;
  };
}

const transformAccountBalancesCurrentData = async (
  rawResponseCurrentData: OperationResult<MercuryAccountBalancesCurrentData>,
  tokenDetails: TokenDetails,
  contractIds: string[],
  networkpassPhrase: StellarSdk.Networks
) => {
  const Sdk = getSdk(networkpassPhrase);
  const { xdr } = Sdk;
  const accountObject = rawResponseCurrentData?.data?.accountByPublicKey;
  const accountCurrentTrustlines =
    rawResponseCurrentData?.data?.trustlinesByPublicKey || [];

  const numSubEntries = accountObject?.numSubentries || "0";
  const numSponsoring = accountObject?.numSponsoring || "0";
  const numSponsored = accountObject?.numSponsored || "0";
  const sellingLiabilities = formatTokenAmount(
    new BigNumber(accountObject?.sellingLiabilities || "0"),
    7
  );
  const buyingLiabilities = formatTokenAmount(
    new BigNumber(accountObject?.buyingLiabilities || "0"),
    7
  );
  const nativeBalance = accountObject?.nativeBalance || "0";

  const accountBalance = {
    native: {
      token: { type: "native", code: "XLM" },
      total: formatTokenAmount(new BigNumber(nativeBalance), 7),
      available: formatTokenAmount(
        new BigNumber(nativeBalance).minus(
          new BigNumber(accountObject?.sellingLiabilities || "0")
        ),
        7
      ),
      buyingLiabilities,
      sellingLiabilities,
      minimumBalance: new BigNumber(BASE_RESERVE_MIN_COUNT)
        .plus(new BigNumber(numSubEntries))
        .plus(new BigNumber(numSponsoring))
        .minus(new BigNumber(numSponsored))
        .times(new BigNumber(BASE_RESERVE))
        .plus(
          new BigNumber(formatTokenAmount(new BigNumber(sellingLiabilities), 7))
        ),
    },
  };

  const classicBalances = accountCurrentTrustlines.reduce((prev, curr) => {
    const tl = curr;
    const trustline = xdr.Asset.fromXDR(tl.asset, "base64");
    switch (trustline.switch().name) {
      case "assetTypeNative": {
        // not in this query, in account object query
        return prev;
      }

      case "assetTypeCreditAlphanum4": {
        const code = trustline.alphaNum4().assetCode().toString();
        const issuer = Sdk.StrKey.encodeEd25519PublicKey(
          trustline.alphaNum4().issuer().ed25519()
        );
        prev[`${code}:${issuer}`] = {
          token: {
            code,
            issuer: {
              key: issuer,
            },
          },
          total: formatTokenAmount(new BigNumber(tl.balance), 7),
          available: formatTokenAmount(new BigNumber(tl.balance), 7),
        };
        return prev;
      }

      case "assetTypeCreditAlphanum12": {
        const code = trustline.alphaNum12().assetCode().toString();
        const issuer = Sdk.StrKey.encodeEd25519PublicKey(
          trustline.alphaNum12().issuer().ed25519()
        );
        prev[`${code}:${issuer}`] = {
          token: {
            code,
            issuer: {
              key: issuer,
            },
          },
          total: formatTokenAmount(new BigNumber(tl.balance), 7),
          available: formatTokenAmount(new BigNumber(tl.balance), 7),
        };
        return prev;
      }

      case "assetTypePoolShare": {
        // Should pool shares be decoded here?
        return prev;
      }

      default:
        throw new Error("Asset type not suppported");
    }
  }, {} as NonNullable<AccountBalancesInterface["balances"]>);

  const tokenBalanceData = contractIds.map((id) => {
    const resData = rawResponseCurrentData?.data || ({} as any);
    const tokenRecord = resData[id] || [];
    return tokenRecord;
  });

  const formattedBalances = tokenBalanceData.map(([entry]) => {
    const details = tokenDetails[entry.contractId];
    const valEntry = xdr.LedgerEntry.fromXDR(entry.valXdr, "base64");
    const val = valEntry.data().contractData().val();
    return {
      ...entry,
      ...details,
      total: Sdk.scValToNative(val),
    };
  });

  const balances = formattedBalances
    .filter(
      (bal) => !isSacContract(bal.name, bal.contractId, networkpassPhrase)
    )
    .reduce((prev, curr) => {
      prev[`${curr.symbol}:${curr.contractId}`] = {
        token: {
          code: curr.symbol,
          issuer: {
            key: curr.contractId,
          },
        },
        decimals: curr.decimals,
        total: new BigNumber(curr.total),
        available: new BigNumber(curr.total),
      };
      return prev;
    }, {} as NonNullable<AccountBalancesInterface["balances"]>);

  return {
    balances: {
      ...accountBalance,
      ...classicBalances,
      ...balances,
    },
    isFunded: true,
    subentryCount: 0,
  };
};

const transformAccountBalances = async (
  rawResponse: OperationResult<MercuryAccountBalancesData>,
  tokenDetails: TokenDetails,
  contractIds: string[],
  network: StellarSdk.Networks
) => {
  const Sdk = getSdk(network);
  const accountObjectData =
    rawResponse?.data?.accountObjectByPublicKey.nodes || [];
  const classicBalanceData = rawResponse?.data?.balanceByPublicKey.nodes || [];

  const accountObject = accountObjectData[0];
  const numSubEntries = accountObject?.numSubEntries || "0";
  const numSponsoring = accountObject?.numSponsoring || "0";
  const numSponsored = accountObject?.numSponsored || "0";
  const sellingLiabilities = accountObject?.sellingLiabilities || "0";
  const nativeBalance = accountObject?.nativeBalance || "0";

  const accountBalance = {
    native: {
      token: { type: "native", code: "XLM" },
      total: formatTokenAmount(new BigNumber(nativeBalance), 7),
      available: new BigNumber(BASE_RESERVE_MIN_COUNT)
        .plus(new BigNumber(numSubEntries))
        .plus(new BigNumber(numSponsoring))
        .minus(new BigNumber(numSponsored))
        .times(new BigNumber(BASE_RESERVE))
        .plus(new BigNumber(sellingLiabilities)),
    },
  };

  const tokenBalanceData = contractIds.map((id) => {
    const resData =
      rawResponse?.data || ({} as { [index: string]: { nodes: [] } });
    const tokenRecord = resData[id] || { nodes: [] };
    return tokenRecord.nodes;
  });

  const formattedBalances = tokenBalanceData.map(([entry]) => {
    const details = tokenDetails[entry.contractId];
    const totalScVal = Sdk.xdr.ScVal.fromXDR(
      Buffer.from(entry.valueXdr, "base64")
    );
    return {
      ...entry,
      ...details,
      total: Sdk.scValToNative(totalScVal),
    };
  });

  const balances = formattedBalances.reduce((prev, curr) => {
    prev[`${curr.symbol}:${curr.contractId}`] = {
      token: {
        code: curr.symbol,
        issuer: {
          key: curr.contractId,
        },
      },
      decimals: curr.decimals,
      total: new BigNumber(curr.total),
      available: new BigNumber(curr.total),
    };
    return prev;
  }, {} as NonNullable<AccountBalancesInterface["balances"]>);

  const classicBalances = classicBalanceData.reduce((prev, curr) => {
    const codeAscii = atob(curr.assetByAsset.code);
    prev[`${codeAscii}:${curr.assetByAsset.issuer}`] = {
      token: {
        code: codeAscii,
        issuer: {
          key: curr.assetByAsset.issuer,
        },
      },
      total: formatTokenAmount(new BigNumber(curr.balance), 7),
      available: formatTokenAmount(new BigNumber(curr.balance), 7),
    };
    return prev;
  }, {} as NonNullable<AccountBalancesInterface["balances"]>);

  return {
    balances: {
      ...accountBalance,
      ...classicBalances,
      ...balances,
    },
    isFunded: true,
    subentryCount: numSubEntries,
  };
};

const transformBaseOperation = (
  operation: BaseOperation,
  network: NetworkNames
) => {
  const Sdk = getSdk(StellarSdk.Networks[network]);
  let isTxSuccessful = true;
  if (operation.txInfoByTx.resultXdr) {
    const { name } = Sdk.xdr.TransactionResult.fromXDR(
      operation.txInfoByTx.resultXdr,
      "base64"
    )
      .result()
      .switch();
    if (name === Sdk.xdr.TransactionResultCode.txFailed().name) {
      isTxSuccessful = false;
    }
  }
  return {
    created_at: new Date(
      operation.txInfoByTx.ledgerByLedger.closeTime * 1000
    ).toISOString(),
    source_account: operation.source,
    transaction_hash: operation.tx,
    id: operation.opId,
    transaction_successful: isTxSuccessful,
    transaction_attr: {
      operation_count: operation.txInfoByTx.opCount,
      fee_charged: operation.txInfoByTx.fee,
    },
  } as Partial<
    StellarSdk.Horizon.ServerApi.BaseOperationRecord & {
      transaction_attr: object;
    }
  >;
};

interface BaseOperation {
  source: string;
  tx: string;
  opId: string;
  txInfoByTx: TxInfo;
}

interface TxInfo {
  fee: string;
  opCount: number;
  resultXdr: string;
  ledgerByLedger: {
    closeTime: number;
  };
}

type MercuryAccountHistory = {
  invokeHostFnByPublicKey: {
    edges: {
      node: {
        auth: string;
        hostFunction: string;
        sorobanMeta: string;
      } & BaseOperation;
    }[];
  };
  createAccountByPublicKey: {
    edges: {
      node: {
        destination: string;
        startingBalance: string;
      } & BaseOperation;
    }[];
  };
  createAccountToPublicKey: {
    edges: {
      node: {
        destination: string;
        startingBalance: string;
      } & BaseOperation;
    }[];
  };
  paymentsOfPublicKey: {
    edges: {
      node: {
        amount: string;
        assetNative: string;
        assetByAsset: {
          code: string;
          issuer: string;
        } | null;
        destination: string;
      } & BaseOperation;
    }[];
  };
  pathPaymentsStrictSendOfPublicKey: {
    nodes: ({
      destination: string;
      assetByDestAsset: {
        code: string;
        issuer: string;
      };
      assetByPath1: {
        code: string;
        issuer: string;
      };
      assetByPath2: {
        code: string;
        issuer: string;
      };
      assetByPath3: {
        issuer: string;
        code: string;
      };
      assetByPath4: {
        issuer: string;
        code: string;
      };
      assetByPath5: {
        issuer: string;
        code: string;
      };
      assetBySendAsset: {
        code: string;
        issuer: string;
      };
      destAssetNative: string;
      destMin: string;
      path1Native: string;
      path2Native: string;
      path3Native: string;
      path4Native: string;
      path5Native: string;
      sendAmount: string;
      sendAssetNative: string;
    } & BaseOperation)[];
  };
  pathPaymentsStrictReceiveOfPublicKey: {
    nodes: ({
      destination: string;
      assetByDestAsset: {
        code: string;
        issuer: string;
      };
      assetByPath1: {
        code: string;
        issuer: string;
      };
      assetByPath2: {
        code: string;
        issuer: string;
      };
      assetByPath3: {
        issuer: string;
        code: string;
      };
      assetByPath4: {
        issuer: string;
        code: string;
      };
      assetByPath5: {
        issuer: string;
        code: string;
      };
      assetBySendAsset: {
        code: string;
        issuer: string;
      };
      destAssetNative: string;
      destMin: string;
      path1Native: string;
      path2Native: string;
      path3Native: string;
      path4Native: string;
      path5Native: string;
      destAmount: string;
      sendAssetNative: string;
    } & BaseOperation)[];
  };
  manageBuyOfferByPublicKey: {
    edges: {
      node: {
        buyingNative: boolean;
        assetByBuying: {
          issuer: string;
          code: string;
        };
        assetBySelling: {
          code: string;
          issuer: string;
        };
        ledgerByLedger: {
          closeTime: number;
          sequence: string;
        };
        source: string;
        offerId: string;
        priceD: string;
        priceN: string;
        sellingNative: boolean;
      } & BaseOperation;
    }[];
  };
  manageSellOfferByPublicKey: {
    edges: {
      node: {
        buyingNative: boolean;
        assetByBuying: {
          issuer: string;
          code: string;
        };
        assetBySelling: {
          code: string;
          issuer: string;
        };
        ledgerByLedger: {
          closeTime: number;
          sequence: string;
        };
        source: string;
        offerId: string;
        priceD: string;
        priceN: string;
        sellingNative: boolean;
      } & BaseOperation;
    }[];
  };
  createPassiveSellOfferByPublicKey: {
    nodes: ({
      amount: string;
      assetByBuying: {
        code: string;
        issuer: string;
      };
      assetBySelling: {
        code: string;
        issuer: string;
      };
      buyingNative: boolean;
      ledgerByLedger: {
        closeTime: number;
        sequence: string;
      };
      source: string;
      priceD: string;
      priceN: string;
      sellingNative: boolean;
    } & BaseOperation)[];
  };
  changeTrustByPublicKey: {
    nodes: ({
      assetByLineAsset: {
        issuer: string;
        code: string;
      };
      limit: string;
      lineNative: boolean;
      poolshareByLinePoolShare: {
        assetByA: {
          code: string;
        };
        assetByB: {
          code: string;
        };
        fee: string;
      };
    } & BaseOperation)[];
  };
  accountMergeByPublicKey: {
    edges: {
      node: {
        destination: string;
        source: string;
      } & BaseOperation;
    }[];
  };
  bumpSequenceByPublicKey: {
    edges: {
      node: {
        source: string;
        bumpTo: string;
      } & BaseOperation;
    }[];
  };
  claimClaimableBalanceByPublicKey: {
    edges: {
      node: {
        source: string;
        balanceId: string;
      } & BaseOperation;
    }[];
  };
  createClaimableBalanceByPublicKey: {
    edges: {
      node: {
        amount: string;
        asset: string;
        assetNative: boolean;
        source: string;
      } & BaseOperation;
    }[];
  };
  allowTrustByPublicKey: {
    edges: {
      node: {
        authorize: boolean;
        code: string;
        source: string;
        trustor: string;
      } & BaseOperation;
    }[];
  };
  manageDataByPublicKey: {
    edges: {
      node: {
        dataName: string;
        dataValue: string;
        source: string;
      } & BaseOperation;
    }[];
  };
  beginSponsoringFutureReservesByPublicKey: {
    edges: {
      node: {
        source: string;
      } & BaseOperation;
    }[];
  };
  endSponsoringFutureReservesByPublicKey: {
    edges: {
      node: {
        source: string;
      } & BaseOperation;
    }[];
  };
  revokeSponsorshipByPublicKey: {
    edges: {
      node: {
        source: string;
        sponsorship: string;
      } & BaseOperation;
    }[];
  };
  clawbackByPublicKey: {
    edges: {
      node: {
        amount: string;
        asset: string;
        assetNative: boolean;
        from: string;
        source: string;
      } & BaseOperation;
    }[];
  };
  setTrustLineFlagsByPublicKey: {
    edges: {
      node: {
        asset: string;
        assetNative: boolean;
        clearFlags: boolean;
        setFlags: boolean;
        source: string;
        trustor: string;
      } & BaseOperation;
    }[];
  };
  liquidityPoolDepositByPublicKey: {
    edges: {
      node: {
        maxAmountA: string;
        maxAmountB: string;
        maxPriceD: string;
        maxPriceN: string;
        minPriceD: string;
        source: string;
      } & BaseOperation;
    }[];
  };
  liquidityPoolWithdrawByPublicKey: {
    edges: {
      node: {
        amount: string;
        minAmountA: string;
        minAmountB: string;
        source: string;
      } & BaseOperation;
    }[];
  };
  createClaimableBalanceToPublicKey: {
    edges: {
      node: {
        amount: string;
        asset: string;
        assetNative: boolean;
        source: string;
        claimants: string;
        destinationsPublic: string[];
      } & BaseOperation;
    }[];
  };
  setOptionsByPublicKey: {
    edges: {
      node: {
        clearFlags: number | null;
        setFlags: number | null;
        masterWeight: number | null;
        lowThreshold: number | null;
        medThreshold: number | null;
        highThreshold: number | null;
        homeDomain: string | null;
        signerWeight: number | null;
        signerKind: string;
        signer: string;
        signedPayload: string | null;
      } & BaseOperation;
    }[];
  };
};

const transformAccountHistory = async (
  rawResponse: OperationResult<MercuryAccountHistory>,
  network: NetworkNames
): Promise<Partial<StellarSdk.Horizon.ServerApi.OperationRecord>[]> => {
  const Sdk = getSdk(StellarSdk.Networks[network]);
  const invokeHostFnEdges =
    rawResponse.data?.invokeHostFnByPublicKey.edges || [];
  const invokeHostFn = invokeHostFnEdges
    .filter((edge) => {
      // we only want to keep these history entries if the Host Fn is
      // for invoking a contract, we dont show contract create or wasm upload in wallet history right now.
      try {
        const hostFn = Sdk.xdr.HostFunction.fromXDR(
          Buffer.from(edge.node.hostFunction, "base64")
        );
        hostFn.invokeContract();
        return true;
      } catch (error) {
        return false;
      }
    })
    .map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      const hostFn = Sdk.xdr.HostFunction.fromXDR(
        Buffer.from(edge.node.hostFunction, "base64")
      );

      const invocation = hostFn.invokeContract();
      const fnName = invocation.functionName().toString();

      return {
        ...baseFields,
        type: "invoke_host_function",
        type_i: 24,
        transaction_attr: {
          ...baseFields.transaction_attr,
          contractId: Sdk.StrKey.encodeContract(
            invocation.contractAddress().contractId()
          ),
          fnName,
          args: getOpArgs(fnName, invocation.args(), network),
          result_meta_xdr: edge.node.sorobanMeta,
        },
      } as Partial<StellarSdk.Horizon.ServerApi.InvokeHostFunctionOperationRecord>;
    });

  const createAccountEdges =
    rawResponse.data?.createAccountByPublicKey.edges || [];
  const createAccount = createAccountEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      account: edge.node.destination,
      starting_balance: formatTokenAmount(
        new BigNumber(edge.node.startingBalance),
        7
      ),
      type: "create_account",
      type_i: 0,
    } as Partial<StellarSdk.Horizon.ServerApi.CreateAccountOperationRecord>;
  });

  const createAccountToEdges =
    rawResponse.data?.createAccountToPublicKey.edges || [];
  const createAccountTo = createAccountToEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      account: edge.node.destination,
      starting_balance: formatTokenAmount(
        new BigNumber(edge.node.startingBalance),
        7
      ),
      type: "create_account",
      type_i: 0,
    } as Partial<StellarSdk.Horizon.ServerApi.CreateAccountOperationRecord>;
  });

  const paymentsByPublicKeyEdges =
    rawResponse.data?.paymentsOfPublicKey.edges || [];
  const paymentsByPublicKey = paymentsByPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    const code = edge.node.assetByAsset
      ? atob(edge.node.assetByAsset?.code!)
      : null;
    const issuer = edge.node.assetByAsset
      ? edge.node.assetByAsset.issuer
      : null;

    return {
      ...baseFields,
      from: edge.node.source,
      to: edge.node.destination,
      asset_type: code,
      asset_code: code,
      asset_issuer: issuer,
      amount: formatTokenAmount(new BigNumber(edge.node.amount), 7),
      type: "payment",
      type_i: 1,
    } as Partial<StellarSdk.Horizon.ServerApi.PaymentOperationRecord>;
  });

  const pathPaymentsStrictSendByPublicKeyEdges =
    rawResponse.data?.pathPaymentsStrictSendOfPublicKey.nodes || [];
  const pathPaymentsStrictSendByPublicKey =
    pathPaymentsStrictSendByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge, network);
      const code = edge.destAssetNative
        ? undefined
        : atob(edge.assetByDestAsset.code);
      const transformedFields = {
        ...baseFields,
        type: "path_payment_strict_send",
        type_i: 13,
        asset_type: getAssetType(code),
        source_account: edge.source,
        from: edge.source,
        to: edge.destination,
        destination_min: edge.destMin,
        amount: formatTokenAmount(new BigNumber(edge.sendAmount), 7),
      } as Partial<StellarSdk.Horizon.ServerApi.PathPaymentStrictSendOperationRecord>;

      if (!edge.destAssetNative) {
        transformedFields.asset_code = atob(edge.assetByDestAsset.code);
        transformedFields.asset_issuer = edge.assetByDestAsset.issuer;
      }
      return transformedFields;
    });

  const pathPaymentsStrictReceiveByPublicKeyEdges =
    rawResponse.data?.pathPaymentsStrictReceiveOfPublicKey.nodes || [];
  const pathPaymentsStrictReceiveByPublicKey =
    pathPaymentsStrictReceiveByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge, network);
      const code = edge.destAssetNative
        ? undefined
        : atob(edge.assetByDestAsset.code);
      const transformedFields = {
        ...baseFields,
        created_at: new Date(
          edge.txInfoByTx.ledgerByLedger.closeTime * 1000
        ).toISOString(),
        type: "path_payment_strict_receive",
        type_i: 2,
        asset_type: getAssetType(code),
        source_account: edge.source,
        from: edge.source,
        to: edge.destination,
        destination_min: edge.destMin,
        amount: formatTokenAmount(new BigNumber(edge.destAmount), 7),
      } as Partial<StellarSdk.Horizon.ServerApi.PathPaymentOperationRecord>;
      if (!edge.destAssetNative) {
        transformedFields.asset_code = atob(edge.assetByDestAsset.code);
        transformedFields.asset_issuer = edge.assetByDestAsset.issuer;
      }
      return transformedFields;
    });

  const manageBuyOfferByPublicKeyEdges =
    rawResponse.data?.manageBuyOfferByPublicKey.edges || [];
  const manageBuyOfferByPublicKey = manageBuyOfferByPublicKeyEdges.map(
    (edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "manage_sell_offer",
        type_i: 4,
      } as Partial<StellarSdk.Horizon.ServerApi.ManageOfferOperationRecord>;
    }
  );

  const manageSellOfferByPublicKeyEdges =
    rawResponse.data?.manageSellOfferByPublicKey.edges || [];
  const manageSellOfferByPublicKey = manageSellOfferByPublicKeyEdges.map(
    (edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "manage_sell_offer",
        type_i: 4,
      } as Partial<StellarSdk.Horizon.ServerApi.ManageOfferOperationRecord>;
    }
  );

  const createPassiveSellOfferByPublicKeyEdges =
    rawResponse.data?.createPassiveSellOfferByPublicKey.nodes || [];
  const createPassiveSellOfferByPublicKey =
    createPassiveSellOfferByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge, network);
      return {
        ...baseFields,
        type: "create_passive_sell_offer",
        type_i: 3,
      } as Partial<StellarSdk.Horizon.ServerApi.PassiveOfferOperationRecord>;
    });

  const changeTrustByPublicKeyEdges =
    rawResponse.data?.changeTrustByPublicKey.nodes || [];
  const changeTrustByPublicKey = changeTrustByPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge, network);
    return {
      ...baseFields,
      type: "change_trust",
      type_i: 6,
    } as Partial<StellarSdk.Horizon.ServerApi.ChangeTrustOperationRecord>;
  });

  const accountMergeByPublicKeyEdges =
    rawResponse.data?.accountMergeByPublicKey.edges || [];
  const accountMergeByPublicKey = accountMergeByPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      type: "account_merge",
      type_i: 8,
    } as Partial<StellarSdk.Horizon.ServerApi.AccountMergeOperationRecord>;
  });

  const bumpSequenceByPublicKeyEdges =
    rawResponse.data?.bumpSequenceByPublicKey.edges || [];
  const bumpSequenceByPublicKey = bumpSequenceByPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      type: "bump_sequence",
      type_i: 11,
    } as Partial<StellarSdk.Horizon.ServerApi.BumpSequenceOperationRecord>;
  });

  const claimClaimableBalanceByPublicKeyEdges =
    rawResponse.data?.claimClaimableBalanceByPublicKey.edges || [];
  const claimClaimableBalanceByPublicKey =
    claimClaimableBalanceByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "claim_claimable_balance",
        type_i: 15,
      } as Partial<StellarSdk.Horizon.ServerApi.ClaimClaimableBalanceOperationRecord>;
    });

  const createClaimableBalanceByPublicKeyEdges =
    rawResponse.data?.createClaimableBalanceByPublicKey.edges || [];
  const createClaimableBalanceByPublicKey =
    createClaimableBalanceByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "create_claimable_balance",
        type_i: 14,
      } as Partial<StellarSdk.Horizon.ServerApi.CreateClaimableBalanceOperationRecord>;
    });

  const allowTrustByPublicKeyEdges =
    rawResponse.data?.allowTrustByPublicKey.edges || [];
  const allowTrustByPublicKey = allowTrustByPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      type: "allow_trust",
      type_i: 7,
    } as Partial<StellarSdk.Horizon.ServerApi.AllowTrustOperationRecord>;
  });

  const manageDataByPublicKeyEdges =
    rawResponse.data?.manageDataByPublicKey.edges || [];
  const manageDataByPublicKey = manageDataByPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      type: "manage_data",
      type_i: 10,
    } as Partial<StellarSdk.Horizon.ServerApi.ManageDataOperationRecord>;
  });

  const beginSponsoringFutureReservesByPublicKeyEdges =
    rawResponse.data?.beginSponsoringFutureReservesByPublicKey.edges || [];
  const beginSponsoringFutureReservesByPublicKey =
    beginSponsoringFutureReservesByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "begin_sponsoring_future_reserves",
        type_i: 16,
      } as Partial<StellarSdk.Horizon.ServerApi.BeginSponsoringFutureReservesOperationRecord>;
    });

  const endSponsoringFutureReservesByPublicKeyEdges =
    rawResponse.data?.endSponsoringFutureReservesByPublicKey.edges || [];
  const endSponsoringFutureReservesByPublicKey =
    endSponsoringFutureReservesByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "end_sponsoring_future_reserves",
        type_i: 17,
      } as Partial<StellarSdk.Horizon.ServerApi.EndSponsoringFutureReservesOperationRecord>;
    });

  const revokeSponsorshipByPublicKeyEdges =
    rawResponse.data?.revokeSponsorshipByPublicKey.edges || [];
  const revokeSponsorshipByPublicKey = revokeSponsorshipByPublicKeyEdges.map(
    (edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "revoke_sponsorship",
        type_i: 18,
      } as Partial<StellarSdk.Horizon.ServerApi.RevokeSponsorshipOperationRecord>;
    }
  );

  const clawbackByPublicKeyEdges =
    rawResponse.data?.clawbackByPublicKey.edges || [];
  const clawbackByPublicKey = clawbackByPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      type: "clawback",
      type_i: 19,
    } as Partial<StellarSdk.Horizon.ServerApi.ClawbackOperationRecord>;
  });

  const setTrustLineFlagsByPublicKeyEdges =
    rawResponse.data?.setTrustLineFlagsByPublicKey.edges || [];
  const setTrustLineFlagsByPublicKey = setTrustLineFlagsByPublicKeyEdges.map(
    (edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "set_trust_line_flags",
        type_i: 21,
      } as Partial<StellarSdk.Horizon.ServerApi.SetTrustLineFlagsOperationRecord>;
    }
  );

  const liquidityPoolDepositByPublicKeyEdges =
    rawResponse.data?.liquidityPoolDepositByPublicKey.edges || [];
  const liquidityPoolDepositByPublicKey =
    liquidityPoolDepositByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "liquidity_pool_deposit",
        type_i: 22,
      } as Partial<StellarSdk.Horizon.ServerApi.DepositLiquidityOperationRecord>;
    });

  const liquidityPoolWithdrawByPublicKeyEdges =
    rawResponse.data?.liquidityPoolWithdrawByPublicKey.edges || [];
  const liquidityPoolWithdrawByPublicKey =
    liquidityPoolWithdrawByPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "liquidity_pool_withdraw",
        type_i: 23,
      } as Partial<StellarSdk.Horizon.ServerApi.WithdrawLiquidityOperationRecord>;
    });

  const createClaimableBalanceToPublicKeyEdges =
    rawResponse.data?.createClaimableBalanceToPublicKey.edges || [];
  const createClaimableBalanceToPublicKey =
    createClaimableBalanceToPublicKeyEdges.map((edge) => {
      const baseFields = transformBaseOperation(edge.node, network);
      return {
        ...baseFields,
        type: "create_claimable_balance",
        type_i: 14,
        amount: edge.node.amount,
        // This is an VecM<Claimant> from the rust sdk which doesnt seem to have a JS counter part, but we dont use this field yet
        // claimants: edge.node.claimants,
        source_account: edge.node.source,
      } as Partial<StellarSdk.Horizon.ServerApi.CreateClaimableBalanceOperationRecord>;
    });

  const setOptionsToPublicKeyEdges =
    rawResponse.data?.setOptionsByPublicKey.edges || [];
  const setOptionsToPublicKey = setOptionsToPublicKeyEdges.map((edge) => {
    const baseFields = transformBaseOperation(edge.node, network);
    return {
      ...baseFields,
      type: "set_options",
      type_i: 5,
      source_account: edge.node.source,
    } as Partial<StellarSdk.Horizon.ServerApi.SetOptionsOperationRecord>;
  });

  return [
    ...createAccount,
    ...createAccountTo,
    ...createClaimableBalanceToPublicKey,
    ...paymentsByPublicKey,
    ...changeTrustByPublicKey,
    ...allowTrustByPublicKey,
    ...accountMergeByPublicKey,
    ...bumpSequenceByPublicKey,
    ...liquidityPoolDepositByPublicKey,
    ...liquidityPoolWithdrawByPublicKey,
    ...pathPaymentsStrictSendByPublicKey,
    ...pathPaymentsStrictReceiveByPublicKey,
    ...claimClaimableBalanceByPublicKey,
    ...createClaimableBalanceByPublicKey,
    ...manageBuyOfferByPublicKey,
    ...manageSellOfferByPublicKey,
    ...createPassiveSellOfferByPublicKey,
    ...manageDataByPublicKey,
    ...beginSponsoringFutureReservesByPublicKey,
    ...endSponsoringFutureReservesByPublicKey,
    ...revokeSponsorshipByPublicKey,
    ...clawbackByPublicKey,
    ...setTrustLineFlagsByPublicKey,
    ...invokeHostFn,
    ...setOptionsToPublicKey,
  ]
    .filter((tx) => tx.transaction_successful)
    .sort((a, b) => {
      const createdA = a.created_at!;
      const createdB = b.created_at!;
      return new Date(createdB).getTime() - new Date(createdA).getTime();
    }); // Mercury indexes first to last and sort is TODO
};

export {
  transformAccountBalances,
  transformAccountHistory,
  transformAccountBalancesCurrentData,
};

================
File: src/service/mercury/index.test.ts
================
import { Horizon, Keypair, Networks, scValToNative, xdr } from "stellar-sdk";
import BigNumber from "bignumber.js";

import { mutation } from "./queries";
import {
  mockMercuryClient,
  queryMockResponse,
  pubKey,
  contractDataEntryValXdr,
} from "../../helper/test-helper";
import { transformAccountBalancesCurrentData } from "./helpers/transformers";
import { ERROR_MESSAGES } from ".";
import { ERROR } from "../../helper/error";
import * as SorobanRpcHelper from "../../helper/soroban-rpc/token";

describe("Mercury Service", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("can fetch account history with a payment-to in history", async () => {
    const { data } = await mockMercuryClient.getAccountHistory(
      pubKey,
      "TESTNET",
      true,
    );
    const payment = (data || []).find((d) => {
      if ("asset_code" in d && d.asset_code === "DT") {
        return true;
      }
      return false;
    }) as Partial<Horizon.ServerApi.PaymentOperationRecord>;
    expect(payment.amount).toEqual("5");
  });

  it("can build a balance ledger key for a pub key", async () => {
    const ledgerKey = mockMercuryClient.tokenBalanceKey(pubKey, "TESTNET");
    const scVal = xdr.ScVal.fromXDR(
      Buffer.from(ledgerKey, "base64"),
    ).value() as xdr.ScVal[];

    const [scValBalance, scValAddress] = scVal;
    const balance = scValToNative(scValBalance);
    const address = scValToNative(scValAddress);
    expect([balance, address]).toEqual(["Balance", pubKey]);
  });

  it("can fetch account balances by pub key", async () => {
    const contracts = [
      "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
      "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
    ];
    const data = await mockMercuryClient.getAccountBalances(
      pubKey,
      contracts,
      "TESTNET",
      true,
    );
    const tokenDetails = {
      CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP: {
        name: "Test Token",
        symbol: "TST",
        decimals: 7,
      },
      CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG: {
        name: "Test Token 2",
        symbol: "TST",
        decimals: 7,
      },
    };

    const transformedData = await transformAccountBalancesCurrentData(
      {
        data: queryMockResponse[
          "query.getAccountBalancesCurrentDataWithBothContracts"
        ],
      } as any,
      tokenDetails as any,
      [
        "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
        "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
      ],
      Networks.TESTNET,
    );
    const expected = {
      ...transformedData,
      error: {
        horizon: null,
        soroban: null,
      },
    };
    expect(data).toEqual(expected);
  });

  it("can renew a token", async () => {
    const response = await mockMercuryClient.renewMercuryToken("TESTNET");
    const expected = {
      data: queryMockResponse[mutation.authenticate],
      error: null,
    };
    expect(response).toEqual(expected);
    expect(mockMercuryClient.tokens["TESTNET"]).toEqual(
      queryMockResponse[mutation.authenticate].authenticate?.jwtToken,
    );
  });

  it("can retry on Mercury GraphQL 401s", async () => {
    const spyRenewToken = jest.spyOn(mockMercuryClient, "renewMercuryToken");

    const expectedResponse = { data: "success!" };
    const mockRetryable = jest.fn();
    mockRetryable.mockRejectedValueOnce(new Error(ERROR_MESSAGES.JWT_EXPIRED));
    mockRetryable.mockReturnValue(expectedResponse);
    const response = await mockMercuryClient.renewAndRetry<
      typeof expectedResponse
    >(mockRetryable, "TESTNET");

    expect(response).toEqual(expectedResponse);
    expect(mockRetryable).toHaveBeenCalledTimes(2);
    expect(spyRenewToken).toHaveBeenCalled();
  });

  it("can retry on Mercury subscription 401s", async () => {
    const spyRenewToken = jest.spyOn(mockMercuryClient, "renewMercuryToken");

    const expectedResponse = { data: "success!" };
    const mockRetryable = jest.fn();
    mockRetryable.mockRejectedValueOnce({ response: { status: 401 } });
    mockRetryable.mockReturnValue(expectedResponse);
    const response = await mockMercuryClient.renewAndRetry<
      typeof expectedResponse
    >(mockRetryable, "TESTNET");

    expect(response).toEqual(expectedResponse);
    expect(mockRetryable).toHaveBeenCalledTimes(2);
    expect(spyRenewToken).toHaveBeenCalled();
  });

  it("will rethrow non 401 errors when !retryCount", async () => {
    const err = "Unexpected";
    const spyRenewToken = jest.spyOn(mockMercuryClient, "renewMercuryToken");

    const mockRetryable = jest.fn();
    mockRetryable.mockRejectedValue(new Error(err));

    await expect(
      mockMercuryClient.renewAndRetry(mockRetryable, "TESTNET"),
    ).rejects.toThrowError(err);
    expect(mockRetryable).toHaveBeenCalledTimes(1);
    expect(spyRenewToken).not.toHaveBeenCalled();
  });

  it("will retry non 401s when retryCount is passed", async () => {
    const err = "Unexpected";
    const RETRY_COUNT = 5;
    const spyRenewToken = jest.spyOn(mockMercuryClient, "renewMercuryToken");

    const expectedResponse = { data: "success!" };
    const mockRetryable = jest.fn();
    mockRetryable.mockRejectedValueOnce(new Error(err));
    mockRetryable.mockReturnValue(expectedResponse);
    const response = await mockMercuryClient.renewAndRetry<
      typeof expectedResponse
    >(mockRetryable, "TESTNET", RETRY_COUNT);

    expect(response).toEqual(expectedResponse);
    // It would retry 5 times, but we can only mock reject once or all so it rejects once, then succeeds.
    expect(mockRetryable).toHaveBeenCalledTimes(2);
    expect(spyRenewToken).not.toHaveBeenCalled();
  });

  it("will correctly handle missing account subscriptions when fetching history", async () => {
    jest
      .spyOn(mockMercuryClient, "getAccountSubForPubKey")
      .mockImplementation(
        (
          ..._args: Parameters<typeof mockMercuryClient.getAccountSubForPubKey>
        ): ReturnType<typeof mockMercuryClient.getAccountSubForPubKey> => {
          return Promise.resolve([{ publickey: "nope" }]);
        },
      );

    jest
      .spyOn(mockMercuryClient, "accountSubscription")
      .mockImplementation(
        (
          ..._args: Parameters<typeof mockMercuryClient.accountSubscription>
        ): ReturnType<typeof mockMercuryClient.accountSubscription> => {
          return Promise.resolve({ data: {}, error: null });
        },
      );

    const response = await mockMercuryClient.getAccountHistoryMercury(
      pubKey,
      "TESTNET",
    );
    expect(response).toHaveProperty("error");
    expect(response.error).toBeInstanceOf(Error);
    if (response.error instanceof Error) {
      expect(response.error.message).toContain(ERROR.MISSING_SUB_FOR_PUBKEY);
    }
    expect(mockMercuryClient.accountSubscription).toHaveBeenCalled();
  });

  it("can properly key SAC balances by asset issuer", async () => {
    const contracts = [
      "CAP5AMC2OHNVREO66DFIN6DHJMPOBAJ2KCDDIMFBR7WWJH5RZBFM3UEI",
      "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
    ];
    jest
      .spyOn(SorobanRpcHelper, "getTokenBalance")
      .mockReturnValue(Promise.resolve(100));
    jest
      .spyOn(SorobanRpcHelper, "getTokenBalance")
      .mockReturnValue(Promise.resolve(100));
    // first contract
    jest.spyOn(mockMercuryClient, "tokenDetails").mockReturnValueOnce(
      Promise.resolve({
        name: "wBTC:GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56",
        symbol: "wBTC",
        decimals: "5",
      }),
    );
    //second contract
    jest.spyOn(mockMercuryClient, "tokenDetails").mockReturnValueOnce(
      Promise.resolve({
        name: "baz",
        symbol: "BAZ",
        decimals: "5",
      }),
    );

    const data = await mockMercuryClient.getTokenBalancesSorobanRPC(
      pubKey,
      contracts,
      "TESTNET",
    );

    const expected = {
      "wBTC:GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56": {
        token: {
          code: "wBTC",
          issuer: {
            key: "CAP5AMC2OHNVREO66DFIN6DHJMPOBAJ2KCDDIMFBR7WWJH5RZBFM3UEI",
          },
        },
        contractId: "CAP5AMC2OHNVREO66DFIN6DHJMPOBAJ2KCDDIMFBR7WWJH5RZBFM3UEI",
        symbol: "wBTC",
        decimals: "5",
        total: new BigNumber(100),
        available: new BigNumber(100),
      },
      "BAZ:CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG": {
        token: {
          code: "BAZ",
          issuer: {
            key: "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
          },
        },
        contractId: "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
        symbol: "BAZ",
        decimals: "5",
        total: new BigNumber(100),
        available: new BigNumber(100),
      },
    };

    expect(data).toEqual(expected);
  });

  it("can remove duplicate balances for SACs", async () => {
    const contracts = [
      "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
      "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
    ];
    jest
      .spyOn(mockMercuryClient, "getAccountBalancesHorizon")
      .mockImplementation(
        (
          ..._args: Parameters<
            typeof mockMercuryClient.getAccountBalancesHorizon
          >
        ): any => {
          return Promise.resolve({
            balances: {
              "yXLM:GARDNV3Q7YGT4AKSDF25LT32YSCCW4EV22Y2TV3I2PU2MMXJTEDL5T55": {
                available: "1.0023247",
                buyingLiabilities: "0",
                limit: "922337203685.4775807",
                sellingLiabilities: "0",
                token: {
                  type: "credit_alphanum4",
                  code: "yXLM",
                  issuer: {
                    key: "GARDNV3Q7YGT4AKSDF25LT32YSCCW4EV22Y2TV3I2PU2MMXJTEDL5T55",
                  },
                  total: "1.0023247",
                },
              },
            },
            id: "",
            network: "TESTNET",
            subentryCount: 1,
            sponsoredCount: 0,
            sponsoringCount: 0,
            sponsor: "",
          });
        },
      );
    jest
      .spyOn(mockMercuryClient, "getTokenBalancesSorobanRPC")
      .mockImplementation(
        (
          ..._args: Parameters<
            typeof mockMercuryClient.getTokenBalancesSorobanRPC
          >
        ): any => {
          return Promise.resolve({
            "FOO:CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP": {
              token: {
                code: "FOO",
                issuer: {
                  key: "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
                },
                total: "1",
              },
            },
            "yXLM:GARDNV3Q7YGT4AKSDF25LT32YSCCW4EV22Y2TV3I2PU2MMXJTEDL5T55": {
              token: {
                code: "yXLM",
                issuer: {
                  key: "CBGTG7XFRY3L6OKAUTR6KGDKUXUQBX3YDJ3QFDYTGVMOM7VV4O7NCODG",
                },
                total: "1",
              },
            },
          });
        },
      );

    const data = await mockMercuryClient.getAccountBalances(
      pubKey,
      contracts,
      "TESTNET",
      false,
    );

    const expected = {
      error: {
        horizon: null,
        soroban: null,
      },
      isFunded: true,
      subentryCount: 1,
      balances: {
        "FOO:CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP": {
          token: {
            code: "FOO",
            issuer: {
              key: "CCWAMYJME4H5CKG7OLXGC2T4M6FL52XCZ3OQOAV6LL3GLA4RO4WH3ASP",
            },
            total: "1",
          },
        },
        "yXLM:GARDNV3Q7YGT4AKSDF25LT32YSCCW4EV22Y2TV3I2PU2MMXJTEDL5T55": {
          available: "1.0023247",
          buyingLiabilities: "0",
          limit: "922337203685.4775807",
          sellingLiabilities: "0",
          token: {
            type: "credit_alphanum4",
            code: "yXLM",
            issuer: {
              key: "GARDNV3Q7YGT4AKSDF25LT32YSCCW4EV22Y2TV3I2PU2MMXJTEDL5T55",
            },
            total: "1.0023247",
          },
        },
      },
    };
    expect(data).toEqual(expected);
  });

  it("can remove duplicate balances when using Mercury", async () => {
    const sacInstance = {
      contract: "CAP5AMC2OHNVREO66DFIN6DHJMPOBAJ2KCDDIMFBR7WWJH5RZBFM3UEI",
      issuer: "GATALTGTWIOT6BUDBCZM3Q4OQ4BO2COLOAZ7IYSKPLC2PMSOPPGF5V56",
      code: "wBTC",
    };
    const contracts = [sacInstance.contract];

    const tokenDetails = {
      [`${sacInstance.contract}`]: {
        name: `${sacInstance.code}:${sacInstance.issuer}`,
        symbol: sacInstance.code,
        decimals: "7",
      },
    };

    const issuer = Keypair.fromPublicKey(sacInstance.issuer).xdrAccountId();
    const alpha = new xdr.AlphaNum4({
      assetCode: Buffer.from(sacInstance.code),
      issuer,
    });
    const asset = xdr.Asset.assetTypeCreditAlphanum4(alpha);

    const rawResponse = {
      data: {
        ...queryMockResponse["query.getAccountBalancesCurrentData"],
        trustlinesByPublicKey: [
          ...queryMockResponse["query.getAccountBalancesCurrentData"]
            .trustlinesByPublicKey,
          {
            balance: 100019646386,
            asset: asset.toXDR("base64"),
            limit: 1,
            accountId: pubKey,
          },
        ],
        [sacInstance.contract]: [
          {
            contractId: sacInstance.contract,
            keyXdr:
              "AAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAAAAAAAAIzohH0YeJGhVUA7vwkk2SzLZ8oNA2zaMGfxtpyxEtys",
            valXdr: contractDataEntryValXdr,
            durability: 1,
          },
        ],
      },
    };

    const transformedResponse = await transformAccountBalancesCurrentData(
      rawResponse as any,
      tokenDetails,
      contracts,
      Networks.TESTNET,
    );
    const wBtcBalances = Object.keys(transformedResponse.balances).filter(
      (key) => key.includes("wBTC"),
    );
    expect(wBtcBalances).toHaveLength(1);
  });
});

================
File: src/service/mercury/index.ts
================
import { Client, CombinedError } from "@urql/core";
import axios from "axios";
import { Logger } from "pino";
import * as StellarSdkNext from "stellar-sdk-next";
import * as StellarSdk from "stellar-sdk";
import { Redis } from "ioredis";
import BigNumber from "bignumber.js";
import Prometheus from "prom-client";

import { mutation, query } from "./queries";
import {
  SOROBAN_RPC_URLS,
  getServer,
  getTokenBalance,
  getTokenDecimals,
  getTokenName,
  getTokenSymbol,
  getTxBuilder,
  isSacContract,
} from "../../helper/soroban-rpc";
import {
  transformAccountBalancesCurrentData,
  transformAccountHistory,
} from "./helpers/transformers";
import {
  AssetBalance,
  fetchAccountDetails,
  fetchAccountHistory,
  NativeBalance,
  NETWORK_URLS,
} from "../../helper/horizon-rpc";
import { NetworkNames } from "../../helper/validate";
import { ERROR } from "../../helper/error";
import {
  MercurySupportedNetworks,
  hasIndexerSupport,
  hasSubForPublicKey,
} from "../../helper/mercury";
import { getSdk } from "../../helper/stellar";

const DEFAULT_RETRY_AMOUNT = 5;

export const ERROR_MESSAGES = {
  JWT_EXPIRED: "1_kJdMBB7ytvgRIqF1clh2iz2iI",
};

function getGraphQlError(error?: CombinedError) {
  if (!error) return;
  const [err] = error.graphQLErrors;

  if (err) {
    return err.message;
  }

  if (error.networkError) {
    return error.networkError.message;
  }

  return JSON.stringify(error);
}

export interface NewEventSubscriptionPayload {
  contract_id?: string;
  max_single_size: number;
  [key: string]: string | number | undefined;
}

export interface NewEntrySubscriptionPayload {
  contract_id?: string;
  key_xdr?: string;
  max_single_size: number;
}

interface MercurySession {
  renewClientMaker(network: NetworkNames): Client;
  backendClientMaker(network: NetworkNames, key: string): Client;
  currentDataClientMaker(network: NetworkNames, key: string): Client;
  backends: {
    TESTNET: string;
    PUBLIC: string;
  };
  credentials: {
    [index: string]: {
      email: string;
      password: string;
    };
    TESTNET: {
      email: string;
      password: string;
    };
    PUBLIC: {
      email: string;
      password: string;
    };
  };
}

interface Balances {
  [key: string]: {};
}

export class MercuryClient {
  mercurySession: MercurySession;
  tokens: {
    [index: string]: string;
    TESTNET: string;
    PUBLIC: string;
  };
  redisClient?: Redis;
  logger: Logger;
  mercuryErrorCounter: Prometheus.Counter<"endpoint">;
  rpcErrorCounter: Prometheus.Counter<"rpc">;
  criticalError: Prometheus.Counter<"message">;

  constructor(
    mercurySession: MercurySession,
    logger: Logger,
    register: Prometheus.Registry,
    metrics: {
      mercuryErrorCounter: Prometheus.Counter<"endpoint">;
      rpcErrorCounter: Prometheus.Counter<"rpc">;
      criticalError: Prometheus.Counter<"message">;
    },
    redisClient?: Redis
  ) {
    this.mercurySession = mercurySession;
    this.logger = logger;
    this.redisClient = redisClient;

    this.mercuryErrorCounter = metrics.mercuryErrorCounter;
    this.rpcErrorCounter = metrics.rpcErrorCounter;
    this.criticalError = metrics.criticalError;

    this.tokens = {
      TESTNET: "",
      PUBLIC: "",
    };

    register.registerMetric(this.mercuryErrorCounter);
    register.registerMetric(this.rpcErrorCounter);
    register.registerMetric(this.criticalError);
  }

  tokenBalanceKey = (pubKey: string, network: NetworkNames) => {
    const Sdk = getSdk(StellarSdk.Networks[network]);
    // { "vec": [{ "symbol": "Balance" }, { "Address": <...pubkey...> }] }
    const addr = new Sdk.Address(pubKey).toScVal();
    return Sdk.xdr.ScVal.scvVec([
      Sdk.xdr.ScVal.scvSymbol("Balance"),
      addr,
    ]).toXDR("base64");
  };

  renewMercuryToken = async (network: NetworkNames) => {
    try {
      if (!hasIndexerSupport(network)) {
        throw new Error(`network not currently supported: ${network}`);
      }
      // we need a second client because the authenticate muation does not ignore the current jwt
      const renewClient = this.mercurySession.renewClientMaker(network);
      const creds = this.mercurySession.credentials[network];
      const { data, error } = await renewClient.mutation(
        mutation.authenticate,
        creds
      );

      if (error) {
        throw new Error(getGraphQlError(error));
      }
      this.tokens[network] = data.authenticate.jwtToken;

      return {
        data,
        error: null,
      };
    } catch (error) {
      return {
        data: null,
        error,
      };
    }
  };

  renewAndRetry = async <T>(
    method: () => Promise<T>,
    network: NetworkNames,
    retryCount?: number
  ): Promise<T> => {
    try {
      return await method();
    } catch (error: any) {
      // renew and retry 0n 401, otherwise throw the error back up to the caller
      if (
        error.message?.includes(ERROR_MESSAGES.JWT_EXPIRED) ||
        error.response?.status === 401
      ) {
        await this.renewMercuryToken(network);
        this.logger.info("renewed expired jwt");
        return await method();
      }

      // Retry in non 401 cases
      if (retryCount) {
        return await this.renewAndRetry(method, network, retryCount - 1);
      }

      this.logger.error(error);
      throw new Error(error);
    }
  };

  tokenSubscription = async (
    contractId: string,
    pubKey: string,
    network: NetworkNames
  ) => {
    const Sdk = getSdk(StellarSdkNext.Networks[network]);
    if (!hasIndexerSupport(network)) {
      return {
        data: null,
        error: `network not currently supported: ${network}`,
      };
    }
    // Token transfer topics are - 1: transfer, 2: from, 3: to, 4: assetName, data(amount)
    const transferToSub = {
      contract_id: contractId,
      max_single_size: 200,
      topic1: Sdk.xdr.ScVal.scvSymbol("transfer").toXDR("base64"),
      topic2: Sdk.xdr.ScVal.scvSymbol(pubKey).toXDR("base64"),
    };
    const transferFromSub = {
      contract_id: contractId,
      max_single_size: 200,
      topic1: Sdk.xdr.ScVal.scvSymbol("transfer").toXDR("base64"),
      topic3: Sdk.xdr.ScVal.scvSymbol(pubKey).toXDR("base64"),
    };
    const mintSub = {
      contract_id: contractId,
      max_single_size: 200,
      topic1: Sdk.xdr.ScVal.scvSymbol("mint").toXDR("base64"),
    };

    try {
      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }

      const subscribe = async () => {
        const config = {
          headers: {
            Authorization: `Bearer ${this.tokens[network]}`,
          },
        };

        const eventsURL = `${
          this.mercurySession.backends[network as MercurySupportedNetworks]
        }/event`;
        const { data: transferFromRes } = await axios.post(
          eventsURL,
          transferToSub,
          config
        );
        const { data: transferToRes } = await axios.post(
          eventsURL,
          transferFromSub,
          config
        );
        const { data: mintRes } = await axios.post(eventsURL, mintSub, config);

        return {
          transferFromRes,
          transferToRes,
          mintRes,
        };
      };

      const { transferFromRes, transferToRes, mintRes } =
        await this.renewAndRetry(subscribe, network, DEFAULT_RETRY_AMOUNT);

      if (!transferFromRes || !transferToRes || !mintRes) {
        throw new Error(ERROR.TOKEN_SUB_FAILED);
      }

      return {
        data: true,
        error: null,
      };
    } catch (error) {
      this.logger.error(error);
      this.criticalError
        .labels({
          message: `Failed to subscribe token history - ${pubKey} on network - ${network} for contract ${contractId}`,
        })
        .inc();
      return {
        data: null,
        error,
      };
    }
  };

  accountSubscription = async (
    pubKey: string,
    network: NetworkNames,
    epochs: number = 6
  ) => {
    if (!hasIndexerSupport(network)) {
      return {
        data: null,
        error: `network not currently supported: ${network}`,
      };
    }

    try {
      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }
      const subscribe = async () => {
        const config = {
          headers: {
            Authorization: `Bearer ${this.tokens[network]}`,
          },
          validateStatus: (status: number) => status < 400,
        };

        const { data } = await axios.post(
          `${
            this.mercurySession.backends[network as MercurySupportedNetworks]
          }/account`,
          { publickey: pubKey, hydrate: true, epochs },
          config
        );
        return data;
      };

      const data = await this.renewAndRetry(
        subscribe,
        network,
        DEFAULT_RETRY_AMOUNT
      );

      return {
        data,
        error: null,
      };
    } catch (error) {
      this.logger.error(error);
      this.criticalError
        .labels({
          message: `Failed to subscribe account - ${pubKey} on network - ${network}`,
        })
        .inc();
      return {
        data: null,
        error,
      };
    }
  };

  tokenBalanceSubscription = async (
    contractId: string,
    pubKey: string,
    network: NetworkNames
  ) => {
    if (!hasIndexerSupport(network)) {
      throw new Error(`network not currently supported: ${network}`);
    }
    try {
      const entrySub = {
        contract_id: contractId,
        max_single_size: 300,
        key_xdr: this.tokenBalanceKey(pubKey, network),
        durability: "persistent",
      };

      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }

      const config = {
        headers: {
          Authorization: `Bearer ${this.tokens[network]}`,
        },
        validateStatus: (status: number) => status < 400,
      };

      const getData = async () => {
        const entryUrl = `${
          this.mercurySession.backends[network as MercurySupportedNetworks]
        }/entry`;
        const { data } = await axios.post(entryUrl, entrySub, config);
        return data;
      };
      const data = await this.renewAndRetry(
        getData,
        network,
        DEFAULT_RETRY_AMOUNT
      );

      if (this.redisClient) {
        await this.tokenDetails(pubKey, contractId, network);
      }

      return {
        data,
        error: null,
      };
    } catch (error) {
      this.logger.error(error);
      this.criticalError
        .labels({
          message: `Failed to subscribe token balance - ${pubKey} on network - ${network} for contract - ${contractId}`,
        })
        .inc();
      return {
        data: null,
        error,
      };
    }
  };

  tokenDetails = async (
    pubKey: string,
    contractId: string,
    network: NetworkNames
  ): Promise<{ name: string; symbol: string; decimals: string }> => {
    try {
      const compositeKey = `${network}__${contractId}`;
      // get from cache if we have them, otherwise go to ledger and cache
      if (this.redisClient) {
        const tokenDetails = await this.redisClient.get(compositeKey);
        if (tokenDetails) {
          return JSON.parse(tokenDetails);
        }
      }
      const server = await getServer(network);
      // we need a builder per operation, 1 op per tx in Soroban
      const decimalsBuilder = await getTxBuilder(pubKey, network, server);
      const decimals = await getTokenDecimals(
        contractId,
        server,
        decimalsBuilder,
        network
      );

      const nameBuilder = await getTxBuilder(pubKey, network, server);
      const name = await getTokenName(contractId, server, nameBuilder, network);

      const symbolsBuilder = await getTxBuilder(pubKey, network, server);
      const symbol = await getTokenSymbol(
        contractId,
        server,
        symbolsBuilder,
        network
      );
      const tokenDetails = {
        name,
        decimals,
        symbol,
      };

      if (this.redisClient) {
        await this.redisClient.set(compositeKey, JSON.stringify(tokenDetails));
      }

      return {
        name,
        decimals,
        symbol,
      };
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(JSON.stringify(error));
    }
  };

  getAccountHistoryHorizon = async (pubKey: string, network: NetworkNames) => {
    try {
      const networkUrl = NETWORK_URLS[network];
      if (!networkUrl) {
        throw new Error(ERROR.UNSUPPORTED_NETWORK);
      }

      const Sdk = getSdk(StellarSdkNext.Networks[network]);
      const { Horizon } = Sdk;

      const server = new Horizon.Server(networkUrl, {
        allowHttp: !networkUrl.includes("https"),
      });
      const data = await fetchAccountHistory(pubKey, server);
      return {
        data,
        error: null,
      };
    } catch (error) {
      const _error = JSON.stringify(error);
      if (error && typeof error === "object" && "message" in error) {
        const err = JSON.parse(error.message as string);
        // Not found errors are normal for unfunded accounts, dont alert
        if (err.name !== "NotFoundError") {
          this.rpcErrorCounter
            .labels({
              rpc: "Horizon",
            })
            .inc();
        }
      }

      return {
        data: null,
        error: _error,
      };
    }
  };

  getAccountHistoryMercury = async (pubKey: string, network: NetworkNames) => {
    try {
      if (!hasIndexerSupport(network)) {
        throw new Error(`network not currently supported: ${network}`);
      }
      const subs = await this.getAccountSubForPubKey(pubKey, network);
      const hasSubs = hasSubForPublicKey(subs, pubKey);
      if (!hasSubs) {
        const { error } = await this.accountSubscription(pubKey, network);
        if (!error) {
          this.logger.info(
            `Subscribed to missing account sub - ${pubKey} - ${network}`
          );
        }
        throw new Error(ERROR.MISSING_SUB_FOR_PUBKEY);
      }

      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }

      const urqlClient = this.mercurySession.backendClientMaker(
        network,
        this.tokens[network]
      );
      const getData = async () => {
        const data = await urqlClient.query(query.getAccountHistory, {
          pubKey,
        });

        const errorMessage = getGraphQlError(data.error);
        if (errorMessage) {
          throw new Error(errorMessage);
        }

        return data;
      };
      const data = await this.renewAndRetry(getData, network);
      return {
        data: await transformAccountHistory(data, network),
        error: null,
      };
    } catch (error) {
      return {
        data: null,
        error,
      };
    }
  };

  getAccountHistory = async (
    pubKey: string,
    network: NetworkNames,
    useMercury: boolean
  ) => {
    if (hasIndexerSupport(network) && useMercury) {
      const response = await this.getAccountHistoryMercury(pubKey, network);

      if (!response.error) {
        return response;
      } else {
        this.logger.error(response.error);
        this.mercuryErrorCounter
          .labels({
            endpoint: "getAccountHistory",
          })
          .inc();
      }
    }

    const horizonResponse = await this.getAccountHistoryHorizon(
      pubKey,
      network
    );
    return horizonResponse;
  };

  getTokenBalancesSorobanRPC = async (
    pubKey: string,
    contractIds: string[],
    network: NetworkNames
  ) => {
    const Sdk = getSdk(StellarSdk.Networks[network]);
    const networkUrl = SOROBAN_RPC_URLS[network];
    if (!networkUrl) {
      throw new Error(ERROR.UNSUPPORTED_NETWORK);
    }

    const balances = [];
    const balanceMap = {} as Record<string, any>;

    const server = await getServer(network);
    for (const id of contractIds) {
      try {
        const builder = await getTxBuilder(pubKey, network, server);
        const params = [new Sdk.Address(pubKey).toScVal()];
        const balance = await getTokenBalance(
          id,
          params,
          server,
          builder,
          network
        );
        const tokenDetails = await this.tokenDetails(pubKey, id, network);
        balances.push({
          id,
          balance,
          ...tokenDetails,
        });
      } catch (error) {
        this.logger.error(error);
        continue;
      }
    }

    for (const balance of balances) {
      const isSac = isSacContract(
        balance.name,
        balance.id,
        StellarSdk.Networks[network]
      );
      const issuerKey = isSac ? balance.name.split(":")[1] : balance.id;

      balanceMap[`${balance.symbol}:${issuerKey}`] = {
        token: {
          code: balance.symbol,
          issuer: {
            key: balance.id,
          },
        },
        contractId: balance.id,
        symbol: balance.symbol,
        decimals: balance.decimals,
        total: new BigNumber(balance.balance),
        available: new BigNumber(balance.balance),
      };
    }
    return balanceMap;
  };

  getAccountBalancesHorizon = async (pubKey: string, network: NetworkNames) => {
    const networkUrl = NETWORK_URLS[network];
    if (!networkUrl) {
      throw new Error(ERROR.UNSUPPORTED_NETWORK);
    }
    const Sdk = getSdk(StellarSdkNext.Networks[network]);
    const { Horizon } = Sdk;

    const server = new Horizon.Server(networkUrl, {
      allowHttp: !networkUrl.includes("https"),
    });
    const resp = await fetchAccountDetails(pubKey, server);

    for (let i = 0; i < Object.keys(resp.balances).length; i++) {
      const k = Object.keys(resp.balances)[i];
      const v = resp.balances[k];
      if ("liquidity_pool_id" in v) {
        const _v =
          v as any as StellarSdk.Horizon.HorizonApi.BalanceLineLiquidityPool;
        const lp = await server
          .liquidityPools()
          .liquidityPoolId(_v.liquidity_pool_id)
          .call();
        resp.balances[k] = {
          ...resp.balances[k],
          liquidityPoolId: _v.liquidity_pool_id,
          reserves: lp.reserves,
        } as
          | AssetBalance
          | (NativeBalance & {
              liquidityPoolId: string;
              reserves: StellarSdk.Horizon.HorizonApi.Reserve[];
            });
        delete (resp.balances[k] as any).liquidity_pool_id;
      }
    }
    return resp;
  };

  getAccountBalancesMercury = async (
    pubKey: string,
    contractIds: string[],
    network: NetworkNames
  ) => {
    try {
      if (!hasIndexerSupport(network)) {
        throw new Error(`network not currently supported: ${network}`);
      }

      const tokenDetails = {} as {
        [index: string]: Awaited<ReturnType<MercuryClient["tokenDetails"]>>;
      };
      for (const contractId of contractIds) {
        const details = await this.tokenDetails(pubKey, contractId, network);
        tokenDetails[contractId] = details;
      }

      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }

      const getData = async () => {
        const urqlClientCurrentData =
          this.mercurySession.currentDataClientMaker(
            network,
            this.tokens[network]
          );

        const responseCurrentData = await urqlClientCurrentData.query(
          query.getCurrentDataAccountBalances(
            pubKey,
            this.tokenBalanceKey(pubKey, network),
            contractIds
          ),
          {}
        );

        const errorMessageCurrentData = getGraphQlError(
          responseCurrentData.error
        );
        if (errorMessageCurrentData) {
          throw new Error(errorMessageCurrentData);
        }

        return responseCurrentData;
      };
      const responseCurrentData = await this.renewAndRetry(getData, network);
      const data = await transformAccountBalancesCurrentData(
        responseCurrentData,
        tokenDetails,
        contractIds,
        StellarSdk.Networks[network]
      );

      return {
        data,
        error: null,
      };
    } catch (error) {
      return {
        data: null,
        error,
      };
    }
  };

  getAccountBalances = async (
    pubKey: string,
    contractIds: string[],
    network: NetworkNames,
    useMercury: boolean
  ) => {
    if (hasIndexerSupport(network) && useMercury) {
      const response = await this.getAccountBalancesMercury(
        pubKey,
        contractIds,
        network
      );

      // if Mercury returns an error, fallback to the RPCs
      if (!response.error && response.data) {
        const { balances, isFunded, subentryCount } = response.data;
        return {
          balances,
          isFunded,
          subentryCount,
          error: {
            horizon: null,
            soroban: null,
          },
        };
      } else {
        this.logger.error(response.error);
        this.mercuryErrorCounter
          .labels({
            endpoint: "getAccountBalance",
          })
          .inc();
      }
    }

    let tokenBalances: Balances = {};
    let classicBalances: {
      balances: Balances;
      subentryCount: number;
    } = {
      balances: {},
      subentryCount: 0,
    };
    let horizonError = null;
    let rpcError = null;
    try {
      classicBalances = await this.getAccountBalancesHorizon(pubKey, network);
    } catch (error) {
      this.logger.error(error);
      this.logger.error(
        `failed to fetch classic balances from Horizon: ${pubKey}, ${network}`
      );
      if (error && typeof error === "object" && "message" in error) {
        const err = JSON.parse(error.message as string);
        // Not found errors are normal for unfunded accounts, dont alert
        if (err.name !== "NotFoundError") {
          horizonError = err;
          this.rpcErrorCounter
            .labels({
              rpc: "Horizon",
            })
            .inc();
        }
      }
    }

    try {
      tokenBalances = await this.getTokenBalancesSorobanRPC(
        pubKey,
        contractIds,
        network
      );
    } catch (error) {
      rpcError = error;
      this.logger.error(error);
      this.logger.error(
        `failed to fetch token balances from Soroban RPC: ${pubKey}, ${network}`
      );
      this.rpcErrorCounter
        .labels({
          rpc: "Soroban",
        })
        .inc();
    }

    const deDupedTokenBalances = { ...tokenBalances };

    Object.keys(tokenBalances).forEach((key) => {
      if (classicBalances.balances[key]) {
        // we have a classic balance for this asset, no need to include the token balance
        delete deDupedTokenBalances[key];
      }
    });

    return {
      balances: {
        ...classicBalances.balances,
        ...deDupedTokenBalances,
      },
      // Horizon 400s when an account is unfunded, so if we have anything in balances we are funded
      isFunded: horizonError
        ? null
        : Boolean(Object.keys(classicBalances.balances).length),
      subentryCount: horizonError ? null : classicBalances.subentryCount,
      error: {
        horizon: horizonError,
        soroban: rpcError,
      },
    };
  };

  getAccountSubForPubKey = async (
    publicKey: string,
    network: NetworkNames
  ): Promise<{ publickey: string }[]> => {
    if (!hasIndexerSupport(network)) {
      throw new Error(`network not currently supported: ${network}`);
    }

    try {
      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }
      const getData = async () => {
        const urqlClient = this.mercurySession.backendClientMaker(
          network,
          this.tokens[network]
        );
        const response = await urqlClient.query(
          query.getAccountSubForPubKey(publicKey),
          {}
        );

        const errorMessage = getGraphQlError(response.error);
        if (errorMessage) {
          throw new Error(errorMessage);
        }

        return response.data.allFullAccountSubscriptionsList;
      };
      const response = await this.renewAndRetry(getData, network);
      return response;
    } catch (error) {
      this.logger.error(error);
      return [];
    }
  };

  getTokenBalanceSub = async (
    publicKey: string,
    contractId: string,
    network: NetworkNames
  ) => {
    if (!hasIndexerSupport(network)) {
      throw new Error(`network not currently supported: ${network}`);
    }
    try {
      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }
      const getData = async () => {
        const urqlClient = this.mercurySession.backendClientMaker(
          network,
          this.tokens[network]
        );
        const response = await urqlClient.query(
          query.getTokenBalanceSub(
            contractId,
            this.tokenBalanceKey(publicKey, network)
          ),
          {}
        );

        const errorMessage = getGraphQlError(response.error);
        if (errorMessage) {
          throw new Error(errorMessage);
        }

        return response.data.allEntryUpdates.nodes;
      };
      const response = await this.renewAndRetry(getData, network);
      return response;
    } catch (error) {
      this.logger.error(error);
      return [];
    }
  };

  checkHydrationStatus = async (hydrationId: number, network: NetworkNames) => {
    try {
      if (!this.tokens[network]) {
        await this.renewMercuryToken(network);
      }
      const subscribe = async () => {
        const config = {
          headers: {
            Authorization: `Bearer ${this.tokens[network]}`,
          },
          validateStatus: (status: number) => status < 400,
        };

        const { data } = await axios.get(
          `${
            this.mercurySession.backends[network as MercurySupportedNetworks]
          }/hydrations/${hydrationId}`,
          config
        );
        return data;
      };

      const data = await this.renewAndRetry(
        subscribe,
        network,
        DEFAULT_RETRY_AMOUNT
      );
      return data;
    } catch (error) {
      this.logger.error(error);
      return { status: "error", id: hydrationId };
    }
  };
}

================
File: src/service/mercury/queries.ts
================
export const mutation = {
  authenticate: `
    mutation Auth($email: String!, $password: String!) {
      authenticate(input: {email: $email, password: $password}) {
        jwtToken
      }
    }
  `,
};
export const query = {
  allSubscriptions: `
    query AllSubscriptions {
      allContractEventSubscriptions {
        edges {
          node {
            contractId
          }
        }
      }
    }
  `,
  getAccountSubForPubKey: (pubKey: string) => `
    query AccountSub {
      allFullAccountSubscriptionsList(first:10, offset:0, condition: { publickey: "${pubKey}" }) {
        publickey
      }
    }
  `,
  getTokenBalanceSub: (contractId: string, keyXdr: string) => `
    query TokenBalanceSub {
      allEntryUpdates(first:10, offset:0, condition: { contractId: "${contractId}", keyXdr: "${keyXdr}" }) {
        nodes {
          contractId
        }
      }
    }
  `,
  getCurrentDataAccountBalances: (
    pubKey: string,
    ledgerKey: string,
    contractIds: string[]
  ) => `
    query AccountBalancesCurrentData {
      trustlinesByPublicKey(public: "${pubKey}") {
        balance
        asset
        limit
        accountId
      }

      accountByPublicKey(public: "${pubKey}") {
        accountId
        nativeBalance
        buyingLiabilities
        sellingLiabilities
        seqNum
        numSubentries
        numSponsored
        numSponsoring
      }

      ${contractIds.map(
        (id) => `
        ${id}: contractDataEntriesByContractAndKeys(contract: "${id}", keys: ["${ledgerKey}"]) {
          contractId,
          keyXdr,
          valXdr,
          durability
        }
        `
      )}
    }
  `,
  getAccountObject: (pubKey: string) => `
    query AccountObject {
      accountObjectByPublicKey(
        publicKeyText: "${pubKey}"
      ) {
        nodes {
          accountByAccount {
            publickey
          }
          nativeBalance
          numSubEntries
          numSponsored
          numSponsoring
          sellingLiabilities
        }
      }
    }
  `,
  getAccountBalances: (
    pubKey: string,
    ledgerKey: string,
    contractIds: string[]
  ) => `
    query AccountBalances {
      accountObjectByPublicKey(
        publicKeyText: "${pubKey}"
      ) {
        nodes {
          accountByAccount {
            publickey
          }
          nativeBalance
          numSubEntries
          numSponsored
          numSponsoring
          sellingLiabilities
        }
      }
      balanceByPublicKey(
        publicKeyText: "${pubKey}"
      ) {
        nodes {
          assetByAsset {
            code
            issuer
          }
          accountByAccount {
            publickey
          }
          balance
        }
      }
      ${contractIds.map(
        (id) =>
          `
        ${id}: entryUpdateByContractIdAndKey(first: 1, ledgerKey: "${ledgerKey}", contract: "${id}") {
          nodes {
            contractId
            keyXdr
            valueXdr
            entryDurability
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
        `
      )}
    }
  `,
  getAccountHistory: `
    query GetAccountHistory($pubKey: String!) {
      invokeHostFnByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            auth
            hostFunction
            sorobanMeta
            source
            tx
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }
      createAccountByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            destination
            startingBalance
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }
      createAccountToPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            destination
            startingBalance
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }
      paymentsOfPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            amount
            assetNative
            assetByAsset {
              code
              issuer
            }
            source
            destination
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      pathPaymentsStrictSendOfPublicKey(publicKeyText: $pubKey) {
        nodes {
          source
          destination
          assetByDestAsset {
            code
            issuer
          }
          assetByPath1 {
            code
            issuer
          }
          assetByPath2 {
            code
            issuer
          }
          assetByPath3 {
            issuer
            code
          }
          assetByPath4 {
            issuer
            code
          }
          assetByPath5 {
            issuer
            code
          }
          assetBySendAsset {
            code
            issuer
          }
          destAssetNative
          destMin
          path1Native
          path2Native
          path3Native
          path4Native
          path5Native
          sendAmount
          sendAssetNative
          opId
          txInfoByTx {
            fee
            opCount
            txHash
            ledger
            resultXdr
            ledgerByLedger {
              closeTime
              sequence
            }
          }
        }
      }

      pathPaymentsStrictReceiveOfPublicKey(publicKeyText: $pubKey) {
        nodes {
          source
          destination
          assetByDestAsset {
            code
            issuer
          }
          assetByPath1 {
            code
            issuer
          }
          assetByPath2 {
            code
            issuer
          }
          assetByPath2 {
            issuer
            code
          }
          assetByPath4 {
            issuer
            code
          }
          assetByPath5 {
            issuer
            code
          }
          assetBySendAsset {
            code
            issuer
          }
          destAssetNative
          path1Native
          path2Native
          path3Native
          path4Native
          path5Native
          sendAssetNative
          destAmount
          sendMax
          opId
          txInfoByTx {
            fee
            opCount
            txHash
            ledger
            resultXdr
            ledgerByLedger {
              closeTime
              sequence
            }
          }
        }
      }
    
      manageBuyOfferByPublicKey(
        publicKeyText: $pubKey
      ) {
        edges {
          node {
            buyingNative
            source
            assetByBuying {
              issuer
              code
            }
            assetBySelling {
              code
              issuer
            }
            offerId
            priceD
            priceN
            sellingNative
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      manageSellOfferByPublicKey(
        publicKeyText: $pubKey
      ) {
        edges {
          node {
            buyingNative
            source
            assetByBuying {
              issuer
              code
            }
            assetBySelling {
              code
              issuer
            }
            offerId
            priceD
            priceN
            sellingNative
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      createPassiveSellOfferByPublicKey(publicKeyText: $pubKey) {
        nodes {
          source
          amount
          assetByBuying {
            code
            issuer
          }
          assetBySelling {
            code
            issuer
          }
          buyingNative
          priceD
          priceN
          sellingNative
          opId
          txInfoByTx {
            fee
            opCount
            txHash
            ledger
            resultXdr
            ledgerByLedger {
              closeTime
              sequence
            }
          }
        }
      }

      changeTrustByPublicKey(publicKeyText: $pubKey) {
        nodes {
          source
          assetByLineAsset {
            issuer
            code
          }
          limit
          lineNative
          poolshareByLinePoolShare {
            assetByA {
              code
            }
            assetByB {
              code
            }
            fee
          }
          opId
          txInfoByTx {
            fee
            opCount
            txHash
            ledger
            resultXdr
            ledgerByLedger {
              closeTime
              sequence
            }
          }
        }
      }

      accountMergeByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            destination
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      bumpSequenceByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            bumpTo
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      claimClaimableBalanceByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            balanceId
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      createClaimableBalanceByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            amount
            asset
            assetNative
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      allowTrustByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            authorize
            code
            source
            trustor
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      manageDataByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            dataName
            dataValue
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      beginSponsoringFutureReservesByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      endSponsoringFutureReservesByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      revokeSponsorshipByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            sponsorship
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      clawbackByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            amount
            asset
            assetNative
            from
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      setTrustLineFlagsByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            asset
            assetNative
            clearFlags
            setFlags
            source
            trustor
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      liquidityPoolDepositByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            maxAmountA
            maxAmountB
            maxPriceD
            maxPriceN
            minPriceD
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      liquidityPoolWithdrawByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            amount
            minAmountA
            minAmountB
            source
            opId
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      createClaimableBalanceToPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            source
            amount
            asset
            assetNative
            source
            claimants
            opId
            destinationsPublic
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }

      setOptionsByPublicKey(publicKeyText: $pubKey) {
        edges {
          node {
            id
            opId
            clearFlags
            setFlags
            masterWeight
            lowThreshold
            medThreshold
            highThreshold
            homeDomain
            signerWeight
            signerKind
            signer
            signedPayload
            source
            txInfoByTx {
              fee
              opCount
              txHash
              ledger
              resultXdr
              ledgerByLedger {
                closeTime
                sequence
              }
            }
          }
        }
      }
      

    }
  `,
};

================
File: src/service/prices/errors.ts
================
type ErrorName =
  | "PriceCacheInitializationError"
  | "PriceCalculationError"
  | "RedisConnectionError"
  | "PriceUpdationError"
  | "UnknownError";

export class TokenPricesError extends Error {
  constructor(name: ErrorName, message: string, cause?: unknown) {
    super(message);
    this.name = name;
    this.cause = cause;
  }
}

export const ensureError = (error: unknown): Error => {
  if (error instanceof TokenPricesError) {
    return error;
  }
  return new TokenPricesError(
    "UnknownError",
    String(error),
    error instanceof Error ? error : undefined,
  );
};

================
File: src/service/prices/index.ts
================
import { Logger } from "pino";
// import { Redis } from "ioredis";
import BigNumber from "bignumber.js";
import * as StellarSdk from "stellar-sdk";
import * as StellarSdkNext from "stellar-sdk-next";
import { getSdk } from "../../helper/stellar";
import { NETWORK_URLS } from "../../helper/horizon-rpc";
import {
  RedisClientType,
  RedisModules,
  RedisFunctions,
  RedisScripts,
} from "redis";
import TimeSeriesCommands from "@redis/time-series";
import { TimeSeriesDuplicatePolicies } from "@redis/time-series";
import { ensureError, TokenPricesError } from "./errors";
const STELLAR_EXPERT_TOP_ASSETS_URL =
  "https://api.stellar.expert/explorer/public/asset-list/top50";
const PRICE_TS_KEY_PREFIX = "ts:price";
const ONE_DAY = 24 * 60 * 60 * 1000; // 1 day in milliseconds
const ONE_MINUTE = 60 * 1000; // 1 minute in milliseconds
const RETENTION_PERIOD = 24 * 60 * 60 * 1000; // 1 day retention period
const USDCAsset = new StellarSdk.Asset(
  "USDC",
  "GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN",
);
const NativeAsset = StellarSdk.Asset.native();
const USD_RECIEIVE_VALUE = new BigNumber(500);
const PRICE_CACHE_INITIALIZED_KEY = "price_cache_initialized";
const TOKEN_UPDATE_BATCH_SIZE = 10; // Process 10 tokens at a time
const TOKEN_COUNTER_SORTED_SET_KEY = "token_counter";
const BATCH_UPDATE_DELAY_MS = 10000; // 5 second delay between batches
const PRICE_CALCULATION_TIMEOUT_MS = 10000;

export interface TokenPriceData {
  currentPrice: BigNumber;
  percentagePriceChange24h: BigNumber | null;
}

type RedisClientWithTS = RedisClientType<
  RedisModules & { ts: typeof TimeSeriesCommands },
  RedisFunctions,
  RedisScripts
>;

export class PriceClient {
  redisClient?: RedisClientWithTS;
  logger: Logger;
  server: StellarSdk.Horizon.Server;
  constructor(logger: Logger, redisClient?: RedisClientWithTS) {
    this.redisClient = redisClient;
    this.logger = logger;
    const Sdk = getSdk(StellarSdkNext.Networks.PUBLIC);
    const { Horizon } = Sdk;
    this.server = new Horizon.Server(NETWORK_URLS.PUBLIC, {
      allowHttp: true,
    });
  }

  getPrice = async (token: string): Promise<TokenPriceData | null> => {
    if (!this.redisClient) {
      return null;
    }

    const tsKey = this.getTimeSeriesKey(token);

    try {
      const latestPrice = await this.redisClient.ts.get(tsKey);

      if (!latestPrice) {
        return this.handleMissingToken(token);
      }

      // Get 24h ago price using TS.RANGE. Use a 1 min offset as the end time.
      const dayAgo = latestPrice.timestamp - ONE_DAY;
      const oldPrices = await this.redisClient.ts.range(
        tsKey,
        dayAgo,
        dayAgo + ONE_MINUTE,
        {
          COUNT: 1,
        },
      );

      const currentPrice = new BigNumber(latestPrice.value);
      let percentagePriceChange24h: BigNumber | null = null;

      if (oldPrices && oldPrices.length > 0) {
        const oldPriceBN = new BigNumber(oldPrices[0].value);
        if (!oldPriceBN.isZero()) {
          percentagePriceChange24h = currentPrice
            .minus(oldPriceBN)
            .dividedBy(oldPriceBN)
            .times(100);
        }
      }
      await this.redisClient.zIncrBy(TOKEN_COUNTER_SORTED_SET_KEY, 1, tsKey);

      return {
        currentPrice,
        percentagePriceChange24h,
      };
    } catch (e) {
      const error = ensureError(e);
      this.logger.error(
        { token },
        "Error getting price from time series",
        error,
      );
      return null;
    }
  };

  initPriceCache = async (): Promise<void> => {
    if (!this.redisClient) {
      throw new TokenPricesError(
        "RedisConnectionError",
        "Redis client not initialized",
      );
    }

    // Get top 50 assets
    const response = await fetch(STELLAR_EXPERT_TOP_ASSETS_URL);
    const data = await response.json();
    const tokens = [
    "XLM",
    ...data.assets.map((asset: any) => `${asset.code}:${asset.issuer}`),
    ];

    for (const token of tokens) {
        const tsKey = this.getTimeSeriesKey(token);
        await this.createTimeSeries(tsKey);
    }

    // Update prices for all tokens
    await this.batchUpdatePrices(tokens);
    await this.redisClient.set(PRICE_CACHE_INITIALIZED_KEY, "true");
  };

  updatePrices = async (): Promise<void> => {
    if (!this.redisClient) {
      throw new TokenPricesError(
        "RedisConnectionError",
        "Redis client not initialized",
      );
    }

    const tokens = await this.redisClient.zRange(
        TOKEN_COUNTER_SORTED_SET_KEY,
        0,
        -1,
        {
          REV: true,
        },
    );
    
    if (tokens.length === 0) {
        this.logger.warn("No tokens found for price update");
        return
    }

    // Process tokens in batches and in decreasing order of popularity (number of times requested).
    // This ensures that the most popular tokens are updated first.
    for (let i = 0; i < tokens.length; i += TOKEN_UPDATE_BATCH_SIZE) {
        const tokenBatch = tokens.slice(i, i + TOKEN_UPDATE_BATCH_SIZE);
        this.logger.info(
            `Processing batch ${i / TOKEN_UPDATE_BATCH_SIZE + 1} of ${Math.ceil(
            tokens.length / TOKEN_UPDATE_BATCH_SIZE,
            )}`,
        );
        await this.batchUpdatePrices(tokenBatch);

        // Add a delay between batches to avoid overloading the price calculation source API.
        await new Promise((resolve) =>
          setTimeout(resolve, BATCH_UPDATE_DELAY_MS),
        );
    }
  };

  private handleMissingToken = async (
    token: string, 
  ): Promise<TokenPriceData | null> => {
    const newPrice = await this.addNewTokenToCache(token);
    return newPrice
      ? { currentPrice: newPrice, percentagePriceChange24h: null }
      : null;
  };

  private getTimeSeriesKey(token: string): string {
    let key = token;
    if (token === "native") {
      key = "XLM";
    }
    return key;
  }

  private async batchUpdatePrices(tokens: string[]): Promise<void> {
    if (!this.redisClient) {
      throw new TokenPricesError(
        "RedisConnectionError",
        "Redis client not initialized",
      );
    }

    // Calculate all prices in parallel
    const pricePromises = tokens.map((token) =>
      this.calculatePriceInUSD(token)
        .then((price) => ({
          token,
          timestamp: price.timestamp,
          price: price.price,
        }))
        .catch((e) => {
            const error = ensureError(e);
            this.logger.error(`Error calculating price for ${token}: ${error.message}`);
            return null;
        }),
    );

    // Filter out null responses - these are tokens for which we failed to calculate a price.
    const prices = (await Promise.all(pricePromises)).filter(
      (
        price,
      ): price is { token: string; timestamp: number; price: BigNumber } =>
        price !== null,
    );

    if (prices.length === 0) {
      throw new TokenPricesError(
        "PriceCalculationError",
        "No prices calculated",
      );
    }
        
    const mAddEntries = prices.map(({ token, timestamp, price }) => ({
        key: this.getTimeSeriesKey(token),
        timestamp,
        value: price.toNumber(),
    }));
    await this.redisClient.ts.mAdd(mAddEntries);
  }

  private async createTimeSeries(key: string): Promise<void> {
    if (!this.redisClient) {
      throw new TokenPricesError(
        "RedisConnectionError",
        "Redis client not initialized",
      );
    }
    
    const created = await this.redisClient.ts.create(key, {
        RETENTION: RETENTION_PERIOD,
        DUPLICATE_POLICY: TimeSeriesDuplicatePolicies.LAST,
        LABELS: {
          PRICE_CACHE_LABEL: PRICE_TS_KEY_PREFIX,
        },
    });
    const addedToSortedSet = await this.redisClient.zIncrBy(
        TOKEN_COUNTER_SORTED_SET_KEY,
        1,
        key,
    );
    this.logger.info(`Created time series ${key}`, created);
    this.logger.info(`Added to sorted set ${key}`, addedToSortedSet);
  }

  private addNewTokenToCache = async (
    token: string,
  ): Promise<BigNumber | null> => {
    if (!this.redisClient) {
      throw new TokenPricesError(
        "RedisConnectionError",
        "Redis client not initialized",
      );
    }

    const { timestamp, price } = await this.calculatePriceInUSD(token);
    const tsKey = this.getTimeSeriesKey(token);

    await this.createTimeSeries(tsKey);
    await this.redisClient.ts.add(tsKey, timestamp, price.toNumber());
    return price;
  };

  private calculatePriceInUSD = async (
    token: string,
  ): Promise<{ timestamp: number; price: BigNumber }> => {
    // Add a 10s timeout to the price calculation
    const timeoutPromise = new Promise<{
        timestamp: number;
        price: BigNumber;
    }>((_, reject) =>
    setTimeout(
        () =>
        reject(
            new TokenPricesError(
            "PriceCalculationError",
            `Price calculation timeout for ${token}`,
            ),
        ),
        PRICE_CALCULATION_TIMEOUT_MS,
    ),
    );

    return await Promise.race([
        this.calculatePriceUsingPaths(token),
        timeoutPromise,
    ]);
  };

  private calculatePriceUsingPaths = async (
    token: string,
  ): Promise<{ timestamp: number; price: BigNumber }> => {
    let sourceAssets = undefined;
    if (token === "XLM") {
        sourceAssets = [NativeAsset];
    } else {
        const [code, issuer] = token.split(":");
        if (!code || !issuer) {
          throw new TokenPricesError(
            "PriceCalculationError",
            `Invalid token format: ${token}. Expected 'code:issuer'`,
          );
        }
        sourceAssets = [new StellarSdk.Asset(code, issuer), NativeAsset];
    }

    const latestLedger = await this.server
        .ledgers()
        .order("desc")
        .limit(1)
        .call();
    const latestLedgerTimestamp = new Date(
        latestLedger.records[0].closed_at,
    ).getTime();

    const paths = await this.server
        .strictReceivePaths(
          sourceAssets,
          USDCAsset,
          USD_RECIEIVE_VALUE.toString(),
        )
        .call();
    if (!paths.records.length) {
        throw new TokenPricesError(
            "PriceCalculationError",
            `No paths found for ${token}`,
        );
    }

    const tokenUnit = new BigNumber(paths.records[0].source_amount);
    const unitTokenPrice = USD_RECIEIVE_VALUE.dividedBy(tokenUnit);
    return { timestamp: latestLedgerTimestamp, price: unitTokenPrice };
  };
  //   private calculateTokenPriceUsingTradeAggregations = async (
  //     token: string,
  //     server: StellarSdk.Horizon.Server,
  //   ): Promise<BigNumber> => {
  //     try {
  //       const [code, issuer] = token.split(":");
  //       if (!code || !issuer) {
  //         throw new Error("Invalid token format. Expected 'code:issuer'");
  //       }

  //       // Get the cached XLM price first
  //       let xlmPrice = await this.getPrice("XLM");
  //       if (!xlmPrice || xlmPrice.isZero()) {
  //         xlmPrice = await this.calculateXLMPriceUsingTradeAggregations(server);
  //       }

  //       const endTime = Date.now();
  //       const startTime = endTime - ONE_HOUR;
  //       const tokenAsset = new StellarSdk.Asset(code, issuer);
  //       const tokenXlmAggregations = await server
  //         .tradeAggregation(
  //           tokenAsset,
  //           NativeAsset,
  //           startTime,
  //           endTime,
  //           RESOLUTION,
  //           0, // offset
  //         )
  //         .call();

  //       if (!tokenXlmAggregations.records.length) {
  //         this.logger.warn({ token }, "No token/XLM trade aggregations found");
  //         return new BigNumber(0);
  //       }

  //       // Calculate token price in USD by multiplying with XLM/USD price
  //       const tokenXlmPrice = new BigNumber(tokenXlmAggregations.records[0].avg);
  //       return tokenXlmPrice.times(xlmPrice);
  //     } catch (error) {
  //       this.logger.error(
  //         { token },
  //         "Error calculating price using trade aggregations",
  //         error,
  //       );
  //       return new BigNumber(0);
  //     }
  //   };

  //   private calculateXLMPriceUsingTradeAggregations = async (
  //     server: StellarSdk.Horizon.Server,
  //   ): Promise<BigNumber> => {
  //     const endTime = Date.now();
  //     const startTime = endTime - ONE_HOUR;

  //     const xlmUsdcAggregations = await server
  //       .tradeAggregation(
  //         NativeAsset,
  //         USDCAsset,
  //         startTime,
  //         endTime,
  //         RESOLUTION,
  //         0, // offset
  //       )
  //       .call();

  //     return new BigNumber(xlmUsdcAggregations.records[0].avg);
  //   };
}

================
File: src/service/prices/worker.ts
================
import { createClient } from "redis";
import { workerData } from "worker_threads";
import { logger } from "../../logger";
import { PriceClient } from ".";
import {
  RedisClientType,
  RedisModules,
  RedisFunctions,
  RedisScripts,
} from "redis";
import TimeSeriesCommands from "@redis/time-series";
import { ensureError } from "./errors";
const { hostname, redisConnectionName, redisPort } = workerData;
const PRICE_UPDATE_INTERVAL = 1 * 60 * 1000; // 1 minute in milliseconds
const PRICE_CACHE_INITIALIZED_KEY = "price_cache_initialized";
const NUM_RETRIES_CACHE_INITIALIZATION = 3;
const RETRY_DELAY_MS = 30000; // 30 seconds in milliseconds
type RedisClientWithTS = RedisClientType<
  RedisModules & { ts: typeof TimeSeriesCommands },
  RedisFunctions,
  RedisScripts
>;

const initializePriceCache = async (
  priceClient: PriceClient,
  redisClient: RedisClientWithTS,
): Promise<void> => {
  let lastError: string | undefined;

  for (
    let attempt = 1;
    attempt <= NUM_RETRIES_CACHE_INITIALIZATION;
    attempt++
  ) {
    try {
      logger.info(
        `Attempting price cache initialization (attempt ${attempt}/${NUM_RETRIES_CACHE_INITIALIZATION})`,
      );
      await priceClient.initPriceCache();
      await redisClient.set(PRICE_CACHE_INITIALIZED_KEY, "true");
      return;
    } catch (e) {
      lastError = ensureError(e).message;
      if (attempt < NUM_RETRIES_CACHE_INITIALIZATION) {
        logger.warn(
          { error: lastError },
          `Price cache initialization attempt: ${attempt} failed, retrying in ${RETRY_DELAY_MS / 1000} seconds`,
        );
        await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS));
      }
    }
  }

  throw new Error(
    `Failed to initialize price cache after ${NUM_RETRIES_CACHE_INITIALIZATION} attempts. Last error: ${lastError}`,
  );
};

const main = async () => {
  // Create Redis client with time series module enabled
  const redisClient = createClient({
    socket: {
      host: hostname,
      port: redisPort,
    },
    name: redisConnectionName,
  });
  await redisClient.connect();

  redisClient.on("error", (error: Error) => {
    logger.error({ error: error.message }, "Redis connection error");
  });

  const priceClient = new PriceClient(logger, redisClient);

  // Initialize cache with top 50 assets
  const priceCacheInitialized = await redisClient.get(
    PRICE_CACHE_INITIALIZED_KEY,
  );

  if (!priceCacheInitialized) {
    try {
      await initializePriceCache(priceClient, redisClient);
    } catch (error) {
      logger.error("Fatal error during price cache initialization");
      process.exit(1);
    }
  } else {
    logger.info("Price cache already initialized");
  }

  // Update prices periodically
  setInterval(async () => {
    try {
      await priceClient.updatePrices();
      logger.info("Updated price cache");
    } catch (e) {
      logger.error("Failed to update price cache:", e);
    }
  }, PRICE_UPDATE_INTERVAL);
};

main().catch((e) => {
  logger.error(e);
});

================
File: src/service/prometheus-query/index.ts
================
import axios from "axios";
import { Logger } from "pino";

enum ResponseType {
  MATRIX = "matrix",
  VECTOR = "vector",
  SCALAR = "scalar",
  STRING = "string",
}

interface PromRangeQueryParams {
  [index: string]: string;
  query: string;
  start: string;
  end: string;
}

interface PromResponse {
  resultType: ResponseType;
  result: unknown;
}

export class PrometheusQuery {
  prometheusUrl: string;
  logger: Logger;

  constructor(prometheusUrl: string, logger: Logger) {
    this.prometheusUrl = prometheusUrl;
    this.logger = logger;
  }

  queryRange = async (params: PromRangeQueryParams) => {
    try {
      const search = new URLSearchParams(params);
      const response: PromResponse = await axios.get(
        `${this.prometheusUrl}/range_query?${search.toString()}`
      );
      return response;
    } catch (error) {
      this.logger.error(error);
      return null;
    }
  };
}

================
File: src/types/js-xdr.d.ts
================
declare module "@stellar/js-xdr";

================
File: src/config.ts
================
import { ERROR } from "./helper/error";

const ENV_KEYS = [
  "AUTH_EMAIL",
  "AUTH_PASS",
  "AUTH_EMAIL_TESTNET",
  "AUTH_PASS_TESTNET",
  "HOSTNAME",
  "MODE",
  "REDIS_CONNECTION_NAME",
  "REDIS_PORT",
  "USE_MERCURY",
  "MERCURY_INTEGRITY_CHECK_ACCOUNT_EMAIL",
  "MERCURY_INTEGRITY_CHECK_ACCOUNT_PASS",
  "BLOCKAID_KEY",
];

export function buildConfig(config: Record<string, string | undefined>) {
  const configKeys = Object.keys(config);
  const missingKeys = [] as string[];

  const isMissingKeys = ENV_KEYS.every((key) => {
    if (configKeys.includes(key) || process.env[key]) {
      return true;
    }
    missingKeys.push(key);
    return false;
  });
  if (!isMissingKeys) {
    throw new Error(ERROR.INVALID_ENV(missingKeys.join()));
  }

  return {
    blockAidKey: config.BLOCKAID_KEY || process.env.BLOCKAID_KEY!,
    hostname: config.HOSTNAME || process.env.HOSTNAME!,
    mercuryBackendTestnet: "https://api.mercurydata.app",
    mercuryGraphQLTestnet: "https://api.mercurydata.app/graphql",
    mercuryBackendPubnet: "https://mainnet.mercurydata.app",
    mercuryGraphQLPubnet: "https://mainnet.mercurydata.app/graphql",
    mercuryGraphQLCurrentDataTestnet:
      "https://api.mercurydata.app:2096/graphql",
    mercuryGraphQLCurrentDataPubnet:
      "https://mainnet.mercurydata.app:2096/graphql",
    mercuryEmail: config.AUTH_EMAIL || process.env.AUTH_EMAIL!,
    mercuryPassword: config.AUTH_PASS || process.env.AUTH_PASS!,
    mercuryEmailTestnet:
      config.AUTH_EMAIL_TESTNET || process.env.AUTH_EMAIL_TESTNET!,
    mercuryPasswordTestnet:
      config.AUTH_PASS_TESTNET || process.env.AUTH_PASS_TESTNET!,
    mercuryIntegrityCheckEmail:
      config.MERCURY_INTEGRITY_CHECK_ACCOUNT_EMAIL ||
      process.env.MERCURY_INTEGRITY_CHECK_ACCOUNT_EMAIL!,
    mercuryIntegrityCheckPass:
      config.MERCURY_INTEGRITY_CHECK_ACCOUNT_PASS ||
      process.env.MERCURY_INTEGRITY_CHECK_ACCOUNT_PASS!,
    mode: config.MODE || process.env.MODE!,
    redisConnectionName:
      config.REDIS_CONNECTION_NAME || process.env.REDIS_CONNECTION_NAME!,
    redisPort: Number(config.REDIS_PORT) || Number(process.env.REDIS_PORT!),
    useMercury:
      config.USE_MERCURY === "true" || process.env.USE_MERCURY === "true",
    useSorobanPublic: true,
    sentryKey: config.SENTRY_KEY || process.env.SENTRY_KEY,

    blockaidConfig: {
      useBlockaidDappScanning: true,
      useBlockaidTxScanning: true,
      useBlockaidAssetScanning: true,
    },
  };
}

export type Conf = ReturnType<typeof buildConfig>;

================
File: src/index.ts
================
import * as dotEnv from "dotenv";
import { expand } from "dotenv-expand";
import yargs from "yargs";
import Redis from "ioredis";
import { createClient } from "redis";
import Prometheus from "prom-client";
import { Worker } from "worker_threads";
import Blockaid from "@blockaid/client";

import { logger } from "./logger";
import { buildConfig } from "./config";
import { MercuryClient } from "./service/mercury";
import { initApiServer } from "./route";
import { initMetricsServer } from "./route/metrics";
import {
  REDIS_USE_MERCURY_KEY,
  buildBackendClientMaker,
  buildCurrentDataClientMaker,
  buildRenewClientMaker,
} from "./helper/mercury";
import { isValidMode, mode } from "./helper/env";
import { ERROR } from "./helper/error";
import {
  register,
  mercuryErrorCounter,
  rpcErrorCounter,
  criticalError,
  WorkerMessage,
  dataIntegrityCheckFail,
  dataIntegrityCheckPass,
} from "./helper/metrics";
import { fetchWithTimeout } from "./helper/fetch";
import { BlockAidService } from "./service/blockaid";
import { PriceClient } from "./service/prices";

interface CliArgs {
  env: string;
  port: number;
}

async function main() {
  const _config = dotEnv.config({ path: ".env" });
  expand(_config);

  const config = _config.parsed || {};
  const conf = buildConfig(config);

  const argv = yargs(process.argv).options({
    env: {
      alias: "e",
      type: "string",
      description: "env - production or development",
    },
    port: {
      alias: "p",
      type: "number",
      description: "port for server",
    },
  }).argv as CliArgs;

  const env = argv.env || conf.mode;
  if (!isValidMode(env)) {
    throw new Error(ERROR.INVALID_RUN_MODE);
  }
  const port = argv.port || 3002;
  Prometheus.collectDefaultMetrics({ register });

  const graphQlEndpoints = {
    TESTNET: conf.mercuryGraphQLTestnet,
    PUBLIC: conf.mercuryGraphQLPubnet,
  };

  const graphQlCurrentDataEndpoints = {
    TESTNET: conf.mercuryGraphQLCurrentDataTestnet,
    PUBLIC: conf.mercuryGraphQLCurrentDataPubnet,
  };

  const backends = {
    TESTNET: conf.mercuryBackendTestnet,
    PUBLIC: conf.mercuryBackendPubnet,
  };

  const mercurySession = {
    renewClientMaker: buildRenewClientMaker(graphQlEndpoints),
    backendClientMaker: buildBackendClientMaker(graphQlEndpoints),
    currentDataClientMaker: buildCurrentDataClientMaker(
      graphQlCurrentDataEndpoints,
    ),
    backends,
    credentials: {
      PUBLIC: {
        email: conf.mercuryEmail,
        password: conf.mercuryPassword,
      },
      TESTNET: {
        email: conf.mercuryEmailTestnet,
        password: conf.mercuryPasswordTestnet,
      },
    },
  };

  let redis = undefined;
  let timeSeriesRedis = undefined;

  // use in-memory store in dev
  if (env !== "development") {
    redis = new Redis({
      connectionName: conf.redisConnectionName,
      host: conf.hostname,
      port: conf.redisPort,
      maxRetriesPerRequest: 1,
    });

    redis.on("error", (error: any) => {
      logger.info("redis connection error", error);
      throw new Error(error);
    });

    await redis.set(REDIS_USE_MERCURY_KEY, String(conf.useMercury));

    // Separate Redis client for time series operations
    timeSeriesRedis = createClient({
      socket: {
        host: conf.hostname,
        port: conf.redisPort,
      },
      name: conf.redisConnectionName,
    });
    await timeSeriesRedis.connect();

    timeSeriesRedis.on("error", (error: any) => {
      logger.info("redis time series connection error", error);
      throw new Error(error);
    });
  }

  const blockAidClient = new Blockaid({
    apiKey: conf.blockAidKey,
    fetch: fetchWithTimeout,
  });
  const blockAidService = new BlockAidService(blockAidClient, logger, register);

  const mercuryClient = new MercuryClient(
    mercurySession,
    logger,
    register,
    {
      mercuryErrorCounter,
      rpcErrorCounter,
      criticalError,
    },
    redis,
  );

  const priceClient = new PriceClient(logger, timeSeriesRedis);
  const server = await initApiServer(
    mercuryClient,
    blockAidService,
    priceClient,
    logger,
    conf.useMercury,
    conf.useSorobanPublic,
    register,
    env as mode,
    conf.blockaidConfig,
    redis,
  );
  const metricsServer = await initMetricsServer(register, redis);

  try {
    await server.listen({ port, host: "0.0.0.0" });
    await metricsServer.listen({ port: 9090, host: "0.0.0.0" });

    logger.info(`Running in ${env} mode`);
  } catch (err) {
    server.log.error(err);
    process.exit(1);
  }

  try {
    // Start price update worker
    if (env !== "development" && redis) {
      const priceWorkerData = {
        workerData: {
          hostname: conf.hostname,
          redisConnectionName: conf.redisConnectionName,
          redisPort: conf.redisPort,
        },
      };
      const priceWorker = new Worker(
        "./build/price-worker.js",
        priceWorkerData,
      );

      priceWorker.on("error", (e) => {
        logger.error("Price worker error:", e);
        priceWorker.terminate();
      });

      priceWorker.on("exit", () => {
        logger.info("Price worker exited");
      });
    }

    // the worker is not properly instantiated when running this app with ts-node
    // if you need to test this, build the app with webpack and run the build with node manually
    if (conf.useMercury && env !== "development") {
      const workerData = {
        workerData: {
          hostname: conf.hostname,
          mercuryBackendPubnet: conf.mercuryBackendPubnet,
          mercuryBackendTestnet: conf.mercuryBackendTestnet,
          mercuryEmailTestnet: conf.mercuryEmailTestnet,
          mercuryGraphQLCurrentDataPubnet: conf.mercuryGraphQLCurrentDataPubnet,
          mercuryGraphQLCurrentDataTestnet:
            conf.mercuryGraphQLCurrentDataTestnet,
          mercuryGraphQLPubnet: conf.mercuryGraphQLPubnet,
          mercuryGraphQLTestnet: conf.mercuryGraphQLTestnet,
          mercuryIntegrityCheckEmail: conf.mercuryIntegrityCheckEmail,
          mercuryIntegrityCheckPass: conf.mercuryIntegrityCheckPass,
          mercuryPasswordTestnet: conf.mercuryPasswordTestnet,
          redisConnectionName: conf.redisConnectionName,
          redisPort: conf.redisPort,
          sentryKey: conf.sentryKey,
        },
      };
      const integrityCheckWorker = new Worker("./build/worker.js", workerData);
      integrityCheckWorker.on("message", (message) => {
        const { type } = message;
        switch (type) {
          case WorkerMessage.INTEGRITY_CHECK_FAIL: {
            dataIntegrityCheckFail.inc();
            return;
          }
          case WorkerMessage.INTEGRITY_CHECK_PASS: {
            dataIntegrityCheckPass.inc();
            return;
          }

          default: {
            logger.error(`Worker message type not supported: ${type}`);
          }
        }
      });
      integrityCheckWorker.on("error", (e) => {
        logger.error(e);
        integrityCheckWorker.terminate();
      });
      integrityCheckWorker.on("exit", () => {
        logger.info("Integrity checker worker exited");
      });
    }
  } catch (err) {
    logger.error(err);
  }

  process.on("SIGTERM", async () => {
    register.clear();
    await server.close();
    process.exit(0);
  });

  process.on("SIGINT", function () {
    process.exit(0);
  });
}

process.on("uncaughtException", function (err) {
  logger.error(err);
  process.kill(process.pid, "SIGTERM");
});

process.on("unhandledRejection", function (reason: string) {
  logger.error(reason);
});

main().catch((e) => {
  logger.error(e);
  process.exit(1);
});

================
File: src/logger.ts
================
import pino from "pino";

const urlToRedacted = (url: string) => {
  if (url.includes("/api/v1/account-history")) {
    return "/api/v1/account-history";
  }
  if (url.includes("/api/v1/account-balances")) {
    return "/api/v1/account-balances";
  }
  return url;
};

const logger = pino({
  name: "freighter-logger",
  serializers: {
    req: pino.stdSerializers.req,
    err: pino.stdSerializers.err,
    error: pino.stdSerializers.err,
  },
  transport: {
    target: "pino-pretty",
    options: {
      colorize: true,
    },
  },
  redact: {
    paths: [
      "req.remoteAddress",
      "req.remotePort",
      "req.headers.host",
      "req.headers['user-agent']",
      "req.url",
      "req.params.pubKey",
      "req.query.pub_key",
    ],
    censor: (value: string, path: string[]) => {
      const _path = path.join(".");
      if (_path === "req.url") {
        return urlToRedacted(value);
      }
      return "Redacted";
    },
  },
});

export { logger };

================
File: .dockerignore
================
node_modules
npm-debug.log
yarn-error.log

================
File: .env-EXAMPLE
================
AUTH_EMAIL=not-set
AUTH_PASS=not-set
AUTH_EMAIL_TESTNET=not-set
AUTH_PASS_TESTNET=not-set
REDIS_CONNECTION_NAME=not-set
REDIS_PORT=not-set
HOSTNAME=not-set
MODE=not-set
USE_MERCURY=not-set
MERCURY_INTEGRITY_CHECK_ACCOUNT_EMAIL=not-set
MERCURY_INTEGRITY_CHECK_ACCOUNT_PASS=not-set
SENTRY_KEY=not-set
BLOCKAID_KEY=not-set

================
File: .eslintrc.js
================
module.exports = {
  extends: ["@stellar/eslint-config"],
  env: {
    es2020: true,
  },
  globals: {},
  ignorePatterns: ["dist/", "node_modules/", "build/"],
  overrides: [
    {
      files: ["webpack.*.js"],
      rules: {
        "import/no-extraneous-dependencies": [0, { devDependencies: false }],
      },
    },
  ],
  rules: {
    "no-shadow": "off",
    "@typescript-eslint/no-shadow": ["error"],
    "no-unused-vars": "off",
    "@typescript-eslint/no-unused-vars": ["error"],
    "no-console": "off",
    "react/jsx-filename-extension": ["error", { extensions: [".tsx", ".jsx"] }],
  },
  settings: {
    "import/resolver": {
      typescript: {},
      node: {
        extensions: [".ts", ".tsx"],
        moduleDirectory: ["node_modules", "src"],
      },
    },
  },
};

================
File: .gitignore
================
.env
node_modules
build
.vscode
dist
*.mdc

================
File: CHANGELOG.md
================
# Release notes - Wallets - Freighter-Backend-1.0.0

Adds support for Soroban RPC on pubnet
Adds config toggle to enable turning off Soroban on pubnet

================
File: CODE_OF_CONDUCT.MD
================
# Code of Conduct

Please read the [Code of Conduct](https://github.com/stellar/.github/blob/master/CODE_OF_CONDUCT.md).

================
File: compose.yaml
================
version: "3.9"
services:
  redis:
    image: redis/redis-stack-server:latest
    container_name: freighter-redis
    hostname: freighter-redis
    restart: always
    networks:
      - freighter
    ports:
      - 6379:6379

networks:
  freighter:
    driver: bridge

================
File: CONTRIBUITING.MD
================
# How to contribute

Please read the [Contribution Guide](https://github.com/stellar/.github/blob/master/CONTRIBUTING.md).

================
File: Dockerfile
================
FROM node:23
MAINTAINER SDF Wallets Team <wallet-eng@stellar.org>

RUN mkdir -p /app
WORKDIR /app

COPY . /app/
RUN yarn
RUN yarn build:prod

EXPOSE 3002
CMD ["node", "build/index.js"]

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
};

================
File: Makefile
================
# Check if we need to prepend docker commands with sudo
SUDO := $(shell docker version >/dev/null 2>&1 || echo "sudo")

# If LABEL is not provided set default value
LABEL ?= $(shell git rev-parse --short HEAD)$(and $(shell git status -s),-dirty-$(shell id -u -n))
# If TAG is not provided set default value
TAG ?= stellar/freighter-backend:$(LABEL)
# https://github.com/opencontainers/image-spec/blob/master/annotations.md
BUILD_DATE := $(shell date -u +%FT%TZ)

docker-build:
	$(SUDO) docker build --pull --label org.opencontainers.image.created="$(BUILD_DATE)" -t $(TAG) .

docker-push:
	$(SUDO) docker push $(TAG)

================
File: package.json
================
{
  "name": "freighter-backend",
  "version": "1.1.0",
  "description": "Freighter's indexer integration layer and general backend",
  "main": "index.js",
  "scripts": {
    "start": "npx ts-node --project tsconfig.json src/index.ts",
    "clean": "rm -rf build",
    "build:prod": "yarn clean && webpack --mode production --config ./webpack.prod.js",
    "prepare": "husky install",
    "test": "jest",
    "test:ci": "jest --ci"
  },
  "husky": {
    "hooks": {
      "pre-commit": "concurrently 'pretty-quick --staged' 'lint-staged'",
      "post-merge": "yarn install-if-package-changed",
      "post-checkout": "yarn install-if-package-changed"
    }
  },
  "lint-staged": {
    "src/**/*.ts?(x)": [
      "eslint --fix --max-warnings 0"
    ]
  },
  "author": "wallet-eng@stellar.org",
  "license": "Apache-2.0",
  "private": true,
  "engines": {
    "node": ">=18.12.0"
  },
  "dependencies": {
    "@blockaid/client": "^0.31.0",
    "@fastify/cors": "^10.0.1",
    "@fastify/helmet": "^13.0.0",
    "@fastify/rate-limit": "^10.2.1",
    "@sentry/node": "^8.42.0",
    "@stellar/js-xdr": "^3.1.2",
    "@urql/core": "^5.0.8",
    "ajv": "^8.17.0",
    "axios": "^1.7.9",
    "dotenv-expand": "^12.0.1",
    "fastify": "^5.1.0",
    "ioredis": "^5.4.1",
    "pino": "^9.5.0",
    "pino-pretty": "^13.0.0",
    "prom-client": "^15.1.3",
    "stellar-sdk": "yarn:stellar-sdk@13.0.0-beta.1",
    "stellar-sdk-next": "yarn:stellar-sdk@13.0.0-beta.1",
    "yargs": "^17.7.2",
    "@redis/time-series": "^1.0.0",
    "redis": "^4.7.0"
  },
  "devDependencies": {
    "@babel/preset-typescript": "^7.26.0",
    "@stellar/tsconfig": "^1.0.2",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.1",
    "@types/yargs": "^17.0.33",
    "babel-jest": "^29.7.0",
    "dotenv": "^16.4.7",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "lint-staged": "^15.2.10",
    "prettier": "^3.4.2",
    "pretty-quick": "^4.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.1",
    "typescript": "^5.7.2",
    "webpack": "^5.97.1",
    "webpack-cli": "^5.1.4",
    "webpack-node-externals": "^3.0.0"
  }
}

================
File: README.md
================
# Freighter-Backend

Freighter's indexer integration layer and general backend

## Prerequisites

You will need

- Node (>=20.0): https://nodejs.org/en/download/
- Yarn (>=v1.22.5): https://classic.yarnpkg.com/en/docs/install

## Development

This application relies on a Redis instance when `MODE=production`, you can either run `docker compose up` to use docker to stand up a Redis or you can start one on the standard port manually. If you're running in development mode, it uses a memory store.

To start the server in development mode, run:
`yarn i && yarn start`

For full runbook details, please reference [the runbook.](./docs/runbook.md)

## Production build

`yarn build:prod`

## Mercury Details

This project integrates with Mercury, an indexer for Stellar/Soroban. You can find general developer documentation (in their repo docs)[https://github.com/xycloo/merury-developers-documentation/blob/main/src/SUMMARY.md].

For full integration details, see [the Mercury docs](./docs/mercury.md).

================
File: tsconfig.json
================
{
  "extends": "@stellar/tsconfig",
  "compilerOptions": {
    "importHelpers": false,
    "target": "ESNEXT",
    "lib": ["dom", "dom.iterable", "esnext"],
    "module": "commonjs",
    "jsx": "react",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "inlineSources": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true
  },
  "include": ["src/**/*"],
  "exclude": ["dist", "node_modules"],
  "ts-node": {
    "transpileOnly": true,
    "files": true,
    "compilerOptions": {
      "rootDir": "."
    }
  }
}

================
File: webpack.prod.js
================
const path = require("path");
const nodeExternals = require("webpack-node-externals");
module.exports = [
  {
    entry: "./src/index.ts",
    mode: "production",
    target: "node",
    devtool: "source-map",
    output: {
      path: path.resolve(__dirname, "build"),
      filename: "index.js",
      devtoolModuleFilenameTemplate: "[absolute-resource-path]",
    },
    resolve: {
      extensions: [".ts", ".js"],
    },
    externals: [nodeExternals()],
    module: {
      rules: [
        {
          test: /\.([cm]?ts)$/,
          use: [
            {
              loader: "ts-loader",
              options: {
                compilerOptions: {
                  sourceMap: true,
                },
              },
            },
          ],
        },
      ],
    },
  },
  {
    entry: "./src/service/integrity-checker/worker.ts",
    mode: "production",
    target: "node",
    devtool: "source-map",
    output: {
      path: path.resolve(__dirname, "build"),
      filename: "worker.js",
      devtoolModuleFilenameTemplate: "[absolute-resource-path]",
    },
    resolve: {
      extensions: [".ts", ".js"],
    },
    externals: [nodeExternals()],
    module: {
      rules: [
        {
          test: /\.([cm]?ts)$/,
          use: [
            {
              loader: "ts-loader",
              options: {
                compilerOptions: {
                  sourceMap: true,
                },
              },
            },
          ],
        },
      ],
    },
  },
  {
    entry: "./src/service/prices/worker.ts",
    mode: "production",
    target: "node",
    devtool: "source-map",
    output: {
      path: path.resolve(__dirname, "build"),
      filename: "price-worker.js",
      devtoolModuleFilenameTemplate: "[absolute-resource-path]",
    },
    resolve: {
      extensions: [".ts", ".js"],
    },
    externals: [nodeExternals()],
    module: {
      rules: [
        {
          test: /\.([cm]?ts)$/,
          use: [
            {
              loader: "ts-loader",
              options: {
                compilerOptions: {
                  sourceMap: true,
                },
              },
            },
          ],
        },
      ],
    },
  },
];
